(include 'sys/func.inc)
(include 'gui/canvas/class.inc)
(include 'class/vector/class.inc)
(include 'gui/points/class.inc)

(def-method 'canvas 'fpoly)
	;inputs
	;r0 = canvas object (ptr)
	;r1 = stack array object (ptr)
	;r2 = color (argb)
	;r3 = x (16.16)
	;r4 = y (16.16)
	;r5 = winding mode (0/1)
	;r6 = vector of points objects (ptr)
	;r7 = span function (ptr)
	;outputs
	;r0 = canvas object (ptr)
	;trashes
	;all but r0

	(ptr 'this 'span 'stack)
	(union
		'(ptr 'polygons)
		'(pptr 'iter_end_polygons 'iter_begin_polygons)
		'(pptr 'iter_i 'iter_j 'iter_k 'iter_end))
	(pint 'iter_edge1 'iter_edge2)
	(pint 'iter_begin_polygon 'iter_end_polygon)
	(int 'ys 'ye 'xs 'xe 'x 'y)
	(uint 'mode 'color 'length)

	(push-scope)
	(entry 'canvas 'fpoly {this, stack, color, x, y, mode, polygons, span})
	(call 'canvas 'to_premul {this, color} {_, color})

	;fill edges, find min and max xy, clip edges not visible or redundant
	(assign {x + 0.5, y + 0.5, max_int, min_int, max_int, min_int, 0} {x, y, xs, xe, ys, ye, length})
	(call 'vector 'get_iters {polygons} {_, iter_begin_polygons, iter_end_polygons})
	(loop-while {iter_begin_polygons != iter_end_polygons})
		(call 'points 'get_iters {*iter_begin_polygons} {_, iter_begin_polygon, iter_end_polygon})
		(call 'array 'set_capacity {this->canvas_edges, length + ((iter_end_polygon - iter_begin_polygon) >> 4) * (edge_size >> 3)})
		(call 'array 'get_begin {this->canvas_edges} {_, iter_edge1})
		(assign {iter_edge1 + length * long_size} {iter_edge2})
		(vpif {iter_end_polygon - iter_begin_polygon >= long_size * 6})
			(vp-def (xdifl ydif xdifh iter_begin_polygon iter_end_polygon x1 y1 x2 y2 this iter_edge2 xs xe ys ye))
			(assign {iter_begin_polygon, iter_end_polygon, this, iter_edge2, xs, xe, ys, ye}
				(list iter_begin_polygon iter_end_polygon this iter_edge2 xs xe ys ye))
			(vp-cpy-ir iter_end_polygon (neg long_size) y1)
			(vp-cpy-ir iter_end_polygon (mul -2 long_size) x1)
			(assign {y} (list xdifh))
			(assign {x} (list xdifl))
			(vp-add-rr xdifh y1)
			(vp-add-rr xdifl x1)
			(vp-asr-cr fp_shift y1)
			(loop-start)
				(vp-cpy-ir iter_begin_polygon 0 x2)
				(vp-cpy-ir iter_begin_polygon long_size y2)
				(assign {x} (list xdifl))
				(assign {y} (list xdifh))
				(vp-add-rr xdifl x2)
				(vp-add-rr xdifh y2)
				(vp-cpy-rr x1 xdifl)
				(vp-asr-cr fp_shift xdifl)
				(vp-asr-cr fp_shift y2)
				(vpif `(,xdifl < ,xs))
					(vp-cpy-rr xdifl xs)
				(endif)
				(vpif `(,xdifl > ,xe))
					(vp-cpy-rr xdifl xe)
				(endif)
				(vpif `(,y1 < ,y2))
					(vp-cpy-ir-ui this canvas_cy xdifl)
					(breakif `(,y2 <= ,xdifl))
					(vpif `(,y1 < ,ys))
						(vp-cpy-rr y1 ys)
					(endif)
					(vpif `(,y2 > ,ye))
						(vp-cpy-rr y2 ye)
					(endif)
					(vp-cpy-rr x2 xdifl)
					(vp-cpy-rr y2 ydif)
					(vp-sub-rr x1 xdifl)
					(vp-sub-rr y1 ydif)
					(vp-ext-rr xdifl xdifh)
					(vp-div-rrr ydif xdifh xdifl)
					(vp-cpy-cr 1 ydif)
					(vp-cpy-ri-i x1 iter_edge2 edge_x)
					(vp-cpy-ri-i y1 iter_edge2 edge_ys)
					(vp-cpy-ri-i y2 iter_edge2 edge_ye)
					(vp-cpy-ri-i ydif iter_edge2 edge_w)
					(vp-cpy-ri-i xdifl iter_edge2 edge_dda)
					(vp-add-cr edge_size iter_edge2)
				(elseif `(,y1 > ,y2))
					(vp-cpy-ir-ui this canvas_cy1 xdifl)
					(breakif `(,y2 >= ,xdifl))
					(vpif `(,y2 < ,ys))
						(vp-cpy-rr y2 ys)
					(endif)
					(vpif `(,y1 > ,ye))
						(vp-cpy-rr y1 ye)
					(endif)
					(vp-cpy-rr x1 xdifl)
					(vp-cpy-rr y1 ydif)
					(vp-sub-rr x2 xdifl)
					(vp-sub-rr y2 ydif)
					(vp-ext-rr xdifl xdifh)
					(vp-div-rrr ydif xdifh xdifl)
					(vp-cpy-cr -1 ydif)
					(vp-cpy-ri-i x2 iter_edge2 edge_x)
					(vp-cpy-ri-i y2 iter_edge2 edge_ys)
					(vp-cpy-ri-i y1 iter_edge2 edge_ye)
					(vp-cpy-ri-i ydif iter_edge2 edge_w)
					(vp-cpy-ri-i xdifl iter_edge2 edge_dda)
					(vp-add-cr edge_size iter_edge2)
				(endif)
				(vp-cpy-ir iter_begin_polygon 0 x1)
				(vp-cpy-ir iter_begin_polygon long_size y1)
				(assign {x} (list xdifl))
				(assign {y} (list xdifh))
				(vp-add-rr xdifl x1)
				(vp-add-rr xdifh y1)
				(vp-add-cr (mul long_size 2) iter_begin_polygon)
				(vp-asr-cr fp_shift y1)
			(loop-until `(,iter_begin_polygon == ,iter_end_polygon))
			(assign (list iter_edge2 xs xe ys ye) {iter_edge2, xs, xe, ys, ye})
			(assign {(iter_edge2 - iter_edge1) >> 3} {length})
		(endif)
		(assign {iter_begin_polygons + ptr_size} {iter_begin_polygons})
	(loop-end)

	;clip check
	(vpif {xs < this->canvas_cx1 && xe > this->canvas_cx && ys < this->canvas_cy1 && ye > this->canvas_cy})
		;edge pointers into tracker for sorting
		(call 'array 'set_capacity {this->canvas_edge_tracker, (iter_edge2 - iter_edge1) / edge_size})
		(call 'array 'get_begin {this->canvas_edge_tracker} {_, iter_i})
		(assign {iter_i, iter_i} {iter_j, iter_end})
		(vp-def (iter_end iter_edge1 iter_edge2))
		(assign {iter_end, iter_edge1, iter_edge2} (list iter_end iter_edge1 iter_edge2))
		(loop-while `(,iter_edge1 != ,iter_edge2))
			(vp-cpy-ri iter_edge1 iter_end 0)
			(vp-add-cr edge_size iter_edge1)
			(vp-add-cr ptr_size iter_end)
		(loop-end)
		(assign (list iter_end) {iter_end})
		(call 'array 'sort {this->canvas_edge_tracker, stack, iter_i, iter_end, $sort_on_y, 0})

		(loop-while {ys < ye})
			(breakif {ys >= this->canvas_cy1})

			;mark edges that end on this scan line
			(vp-def (iter_i iter_j iter_end ys min_int edge ye x dda lastx))
			(assign {iter_i, iter_j, iter_end, ys, min_int, min_int} (list iter_i iter_j iter_end ys min_int lastx))
			(loop-while `(,iter_i != ,iter_j))
				(vp-cpy-ir iter_i 0 edge)
				(vp-add-cr ptr_size iter_i)
				(vp-cpy-ir-i edge edge_x x)
				(vp-cpy-ir-i edge edge_ye ye)
				(vpif `(,lastx <= ,x))
					(vp-cpy-rr x lastx)
				(else)
					(vp-cpy-cr max_int lastx)
				(endif)
				(continueif `(,ye != ,ys))
				(vp-cpy-ri-i min_int edge edge_x)
				(vp-cpy-cr max_int lastx)
			(loop-end)

			;include new edges that begin on this scan line
			(loop-while `(,iter_j != ,iter_end))
				(vp-cpy-ir iter_j 0 edge)
				(vp-cpy-ir-i edge edge_ys ye)
				(breakif `(,ye != ,ys))
				(vp-add-cr ptr_size iter_j)
				(vp-cpy-cr max_int lastx)
			(loop-end)
			(assign (list iter_j) {iter_j})

			;sort on x ?, plus move all marked dead edges to front !
			(vpif `(,lastx == max_int))
				(call 'array 'sort {this->canvas_edge_tracker, stack, iter_i, iter_j, $sort_on_x, 0})
			(endif)

			;remove all dead edges
			(assign {iter_i, iter_j, min_int} (list iter_i iter_j min_int))
			(loop-while `(,iter_i != ,iter_j))
				(vp-cpy-ir iter_i 0 edge)
				(vp-cpy-ir-i edge edge_x x)
				(breakif `(,x != ,min_int))
				(vp-add-cr ptr_size iter_i)
			(loop-end)
			(assign (list iter_i) {iter_i})
			(assign (list iter_i) {iter_k})

			(vpif {ys >= this->canvas_cy})
				(vp-def (this col x1 y x2 w v iter_k iter_j iter_edge1 iter_edge2 span)
					(method-input 'canvas 'set_span))
				(vpif {mode})
					;odd even
					(assign {this} (list this))
					(loop-start)
						(assign {iter_k, iter_j} (list iter_k iter_j))
						(breakif `(,iter_k == ,iter_j))
						(assign {color, ys, span} (list col y span))
						(vp-cpy-ir iter_k 0 iter_edge1)
						(vp-cpy-ir iter_k ptr_size iter_edge2)
						(vp-add-cr (mul 2 ptr_size) iter_k)
						(vp-cpy-ir-i iter_edge1 edge_x x1)
						(vp-cpy-ir-i iter_edge2 edge_x x2)
						(vp-asr-cr fp_shift x1)
						(vp-asr-cr fp_shift x2)
						(assign (list iter_k) {iter_k})
						(r-call 'canvas 'set_span (list this col x1 y x2 span) (list this) span)
					(loop-end)
				(else)
					;non zero
					(assign {this} (list this))
					(loop-start)
						(assign {iter_k, iter_j} (list iter_k iter_j))
						(breakif `(,iter_k == ,iter_j))
						(assign {color, ys, span} (list col y span))
						(vp-cpy-ir iter_k 0 iter_edge1)
						(vp-add-cr ptr_size iter_k)
						(vp-cpy-ir-i iter_edge1 edge_w w)
						(vp-cpy-ir-i iter_edge1 edge_x x1)
						(loop-start)
							(vp-cpy-ir iter_k 0 iter_edge2)
							(vp-add-cr ptr_size iter_k)
							(vp-cpy-ir-i iter_edge2 edge_w v)
							(vp-cpy-ir-i iter_edge2 edge_x x2)
							(vp-add-rr v w)
						(loop-until `(,w == 0))
						(vp-asr-cr fp_shift x1)
						(vp-asr-cr fp_shift x2)
						(assign (list iter_k) {iter_k})
						(r-call 'canvas 'set_span (list this col x1 y x2 span) (list this) span)
					(loop-end)
				(endif)
			(endif)

			;step the edges
			(vp-def (iter_i iter_j x dda edge))
			(assign {iter_i, iter_j} (list iter_i iter_j))
			(loop-while `(,iter_i != ,iter_j))
				(vp-cpy-ir iter_i 0 edge)
				(vp-add-cr ptr_size iter_i)
				(vp-cpy-ir-i edge edge_x x)
				(vp-cpy-ir-i edge edge_dda dda)
				(vp-add-rr dda x)
				(vp-cpy-ri-i x edge edge_x)
			(loop-end)

			(assign {ys + 1} {ys})
		(loop-end)
	(endif)

	(exit 'canvas 'fpoly {this})
	(pop-scope)
	(return)

(vp-label 'sort_on_x)
	(vp-cpy-ir r1 0 r1)
	(vp-cpy-ir r2 0 r2)
	(vp-cpy-ir-i r1 edge_x r0)
	(vp-cpy-ir-i r2 edge_x r1)
	(vp-sub-rr r1 r0)
	(vp-ret)

(vp-label 'sort_on_y)
	(vp-cpy-ir r1 0 r1)
	(vp-cpy-ir r2 0 r2)
	(vp-cpy-ir-i r1 edge_ys r0)
	(vp-cpy-ir-i r2 edge_ys r1)
	(vp-sub-rr r1 r0)
	(vp-ret)

(def-func-end)
