(include "lib/asm/func.inc")
(include "gui/canvas/class.inc")
(include "class/str/class.inc")
(include "class/reals/class.inc")
(include "class/real/class.inc")
(include "class/lisp/class.inc")

(defun do-frac (val ftrunc fzero fone trunc)
	(vp-cvt-fr val trunc)
	(vp-cvt-rf trunc ftrunc)
	(vp-sub-ff ftrunc val)
	(vpif `(,val < ,fzero))
		(vp-add-ff fone val)
	(endif))

(defun do-scene (p0 p1 p2 ftrunc fzero fhalf fone f035 trunc)
	;frac
	(do-frac p0 ftrunc fzero fone trunc)
	(do-frac p1 ftrunc fzero fone trunc)
	(do-frac p2 ftrunc fzero fone trunc)
	;minus 0.5
	(vp-simd vp-sub-ff `(,fhalf) `(,p0 ,p1 ,p2))
	;length - 0.35
	(vp-simd vp-mul-ff `(,p0 ,p1 ,p2) `(,p0 ,p1 ,p2))
	(vp-add-ff p1 p0)
	(vp-add-ff p2 p0)
	(vp-sqrt-ff p0 p0)
	(vp-sub-ff f035 p0))

(def-func 'apps/raymarch/scene)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14, :f0-:f7

	(vp-rdef (this args trunc len consts pos))
	(vp-fdef (p0 p1 p2 fhalf ftrunc fzero fone f035))

	(entry `(,this ,args))

	(errorif-lisp-args-sig 'error :r1 1)
	(array-bind-args args `(,pos))
(errorcase
	(assign `((,pos array_length)) `(,len))
	(gotoif `(,len /= 3) 'error))

	(vp-push this)

	;constants
	(vp-lea-p 'constants consts)
	(load-fields consts `(0 ,+long_size ,(* +long_size 2) ,(* +long_size 3))
		`(,fzero ,fone ,f035 ,fhalf))

	;load vector
	(assign `((,pos array_begin)) `(,pos))
	(load-fields pos `(0 ,+long_size ,(* +long_size 2)) `(,p0 ,p1 ,p2))

	(do-scene p0 p1 p2 ftrunc fzero fhalf fone f035 trunc)
	(call 'real :create `(,p0) `(,args))

	(vp-pop this)
	(exit `(,this ,args))
	(vp-ret)

	(vp-align +long_size)
(vp-label 'constants)
	(vp-long (n2r 0.0))
	(vp-long (n2r 1.0))
	(vp-long (n2r 0.35))
	(vp-long (n2r 0.5))

(errorcase
(vp-label 'error)
	(jump 'lisp :repl_error `(,this "(scene reals)" +error_msg_wrong_types ,args))
	(signature '(reals)))

(def-func-end)

(def-func 'apps/raymarch/ray_march)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14, :f0-:f15

	(vp-rdef (this args ray_org ray_dir consts cnt trunc len max_len min_dist march_factor))
	(vp-fdef (p0 p1 p2 p3 p4 p5 flen fmax_len fmin_dist fmarch_factor fd fhalf ftrunc fzero fone f035))

	(entry `(,this ,args))

	(errorif-lisp-args-sig 'error :r1 6)

	(array-bind-args args `(,ray_org ,ray_dir ,len ,max_len ,min_dist ,march_factor))

(errorcase
	(assign `((,ray_org array_length)) `(,cnt))
	(gotoif `(,cnt /= 3) 'error)
	(assign `((,ray_dir array_length)) `(,cnt))
	(gotoif `(,cnt /= 3) 'error))

	(vp-push this)
	(assign `((,ray_org array_begin) (,ray_dir array_begin)) `(,ray_org ,ray_dir))
	(assign `((,len num_value)) `(,flen))
	(assign `((,max_len num_value)) `(,fmax_len))
	(assign `((,min_dist num_value)) `(,fmin_dist))
	(assign `((,march_factor num_value)) `(,fmarch_factor))

	;constants
	(vp-lea-p 'constants consts)
	(load-fields consts `(0 ,+long_size ,(* +long_size 2) ,(* +long_size 3) ,+long_size)
		`(,fzero ,fone ,f035 ,fhalf ,fd))

	(vp-cpy-cr 1000 cnt)
	(loop-start)
		(breakif `(,cnt = 0) `(,flen >= ,fmax_len) `(,fd <= ,fmin_dist))
		(vp-sub-cr 1 cnt)

		;load origin, dir
		(load-fields ray_org `(0 ,+long_size ,(* +long_size 2)) `(,p0 ,p1 ,p2))
		(load-fields ray_dir `(0 ,+long_size ,(* +long_size 2)) `(,p3 ,p4 ,p5))
		;scale dir
		(vp-simd vp-mul-ff `(,flen) `(,p3 ,p4 ,p5))
		;extend origin
		(vp-simd vp-add-ff `(,p3 ,p4 ,p5) `(,p0 ,p1 ,p2))
		;scene sdf
		(do-scene p0 p1 p2 ftrunc fzero fhalf fone f035 trunc)

		;march forward
		(vp-cpy-ff p0 fd)
		(vp-mul-ff fmarch_factor p0)
		(vp-add-ff p0 flen)
	(loop-end)
	(vp-cpy-ff flen p0)
	(vpif `(,fd > ,fmin_dist))
		(vp-cpy-ff fmax_len p0)
	(endif)
	(call 'real :create `(,p0) `(,args))

	(vp-pop this)
	(exit `(,this ,args))
	(vp-ret)

	(vp-align +long_size)
(vp-label 'constants)
	(vp-long (n2r 0.0))
	(vp-long (n2r 1.0))
	(vp-long (n2r 0.35))
	(vp-long (n2r 0.5))

(errorcase
(vp-label 'error)
	(jump 'lisp :repl_error `(,this "(ray-march reals reals real real real real)" +error_msg_wrong_types ,args))
	(signature '(reals reals real real real real)))

(def-func-end)

(def-func 'apps/raymarch/tile)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(ptr this canvas)
		(puint data)
		(uint x y x1 y1 xp yp))

	(entry '(:r0 :r1))

	(errorif-lisp-args-sig 'error :r1 2)

	(push-scope)
	(assign '(:r0) {this})

	(list-bind-args :r1 '(:r0 :r1) '(:canvas :str))
	(array-get-args :r1 '(:r7 :r8 :r9 :r10) 'ui)
	(vp-add-cr (* 4 +int_size) :r1)
	(assign '(:r0 :r1 :r7 :r8 :r9 :r10 :r8) {canvas, data, x, y, x1, y1, yp})
	(loop-start)
		(assign {x} {xp})
		(loop-start)
			(assign {*data} {canvas->canvas_color})
			(call 'canvas :plot {canvas, xp, yp})
			(assign {data + +int_size} {data})
		(loop-until {(xp + 1 => xp) = x1})
	(loop-until {(yp + 1 => yp) = y1})

	(call 'num :create {(x1 - x) * (y1 - y)} '(:r1))

	(assign {this} '(:r0))
	(exit '(:r0 :r1))
	(pop-scope)
	(return)

(errorcase
(vp-label 'error)
	(jump 'lisp :repl_error '(:r0 "(tile canvas data)" +error_msg_wrong_types :r1))
	(signature '(canvas str)))

(def-func-end)
