(import "././login/env.inc")
(import "gui/lisp.inc")
(import "lib/consts/chars.inc")
(import "lib/consts/scodes.inc")

(enums +event 0
	(enum close max min)
	(enum new open save save_as)
	(enum select_widget)
	(enum tree_select)
	(enum prop_edit))

(enums +select 0
	(enum main tip))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Designer State
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defq *designer-tree* :nil)
(defq *designer-selected* :nil)
(defq *designer-file* :nil)
(defq *designer-modified* :nil)

;widget palette definitions
(defq +widget-types (list
	"ui-button" "ui-label" "ui-text" "ui-textfield"
	"ui-flow" "ui-grid" "ui-slider" "ui-progress"
	"ui-canvas" "ui-vdu" "ui-scroll" "ui-backdrop"
	"ui-title" "ui-radio-bar" "ui-toggle-bar"
	"ui-tree" "ui-spinner" "ui-view" "ui-stack"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tree Rendering
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun tree-element-to-string (element &optional indent)
	; (tree-element-to-string element [indent]) -> str
	(setd indent 0)
	(defq spaces "")
	(times indent (setq spaces (cat spaces "  ")))
	(cat spaces
		(get :type element) " "
		(get :name element)
		(if (nempty? (get :children element))
			(cat " [" (str (length (get :children element))) "]")
			"")))

(defun tree-to-strings (element &optional indent results)
	; (tree-to-strings element [indent] [results]) -> (str ...)
	(setd indent 0 results (list))
	(push results (tree-element-to-string element indent))
	(each (lambda (child)
		(tree-to-strings child (inc indent) results))
		(get :children element))
	results)

(defun update-tree-view (tree tree_widget)
	; (update-tree-view tree tree_widget) -> :nil
	(when tree
		(defq lines (tree-to-strings tree))
		;TODO: populate tree widget with lines
		))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Property Inspector
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun format-prop (prop)
	; (format-prop prop) -> str
	(cond
		((lst? prop)
			(if (= (length prop) 2)
				(cat (elem-get prop 0) ": " (str (elem-get prop 1)))
				(str prop)))
		(:t (str prop))))

(defun update-properties (element)
	; (update-properties element) -> :nil
	(when element
		(defq props (get :props element))
		;update property display
		(when props
			(each (lambda (prop)
				(defq prop_str (format-prop prop))
				;TODO: display in property panel
				) (first props)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Serialization
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun indent-str (level)
	; (indent-str level) -> str
	(defq result "")
	(times level (setq result (cat result (ascii-char 9))))
	result)

(defun format-props (props)
	; (format-props props) -> str
	(if (or (not props) (empty? props))
		""
		(progn
			(defq result "(")
			(each! 0 -1 1 (lambda (prop)
				(cond
					((and (lst? prop) (= (length prop) 1))
						(setq result (cat result (elem-get prop 0))))
					((lst? prop)
						(setq result (cat result
							(elem-get prop 0) " "
							(if (str? (elem-get prop 1))
								(cat "\"" (elem-get prop 1) "\"")
								(str (elem-get prop 1))))))
					(:t (setq result (cat result (str prop)))))
				(when (< (!) (dec (length props)))
					(setq result (cat result " ")))) props)
			(cat result ")"))))

(defun serialize-element (element level)
	; (serialize-element element level) -> str
	(defq type (get :type element)
		name (get :name element)
		props (first (get :props element))
		children (get :children element)
		indent (indent-str level)
		result "")

	(setq result (cat indent "(" type " " name))

	(when props
		(setq result (cat result " " (format-props props))))

	(cond
		((empty? children)
			(setq result (cat result ")")))
		(:t
			(setq result (cat result (ascii-char 10)))
			(each (lambda (child)
				(setq result (cat result
					(serialize-element child (inc level))
					(ascii-char 10)))) children)
			(setq result (cat result indent ")"))))

	result)

(defun save-tree (tree filepath)
	; (save-tree tree filepath) -> :t | :nil
	(when tree
		(defq source (serialize-element tree 0))
		;prepend imports and header
		(setq source (cat
			";Auto-generated by ChrysaLisp Designer" (ascii-char 10)
			"(import \"././login/env.inc\")" (ascii-char 10)
			"(import \"gui/lisp.inc\")" (ascii-char 10)
			(ascii-char 10)
			source
			(ascii-char 10)))
		(when (defq stream (file-stream filepath +file_open_write))
			(write stream source)
			:t)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Element Creation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun make-element (type name)
	; (make-element type name) -> element
	(defq id 0)
	(scatter (Lmap)
		:id id
		:type type
		:name name
		:constructor (cat "(" (slice type 3) ")")
		:props (list (list))
		:children (list)))

(defun add-element (parent type)
	; (add-element parent type) -> element
	(defq name (cat "_elem" (str (length (get :children parent)))))
	(defq element (make-element type name))
	(push (get :children parent) element)
	element)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; File Operations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun new-design ()
	; (new-design) -> :nil
	(setq *designer-tree*
		(scatter (Lmap)
			:id 0
			:type "ui-window"
			:name "*window*"
			:constructor "(Window)"
			:props (list (list))
			:children (list)))
	(setq *designer-file* :nil
		*designer-modified* :nil
		*designer-selected* :nil))

(defun save-design (filepath)
	; (save-design filepath) -> :t | :nil
	(when *designer-tree*
		(when (save-tree *designer-tree* filepath)
			(setq *designer-file* filepath
				*designer-modified* :nil)
			:t)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; UI Definition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(ui-window *window* (:min_width 1024 :min_height 768)
	;title bar
	(ui-title-bar _ "ChrysaLisp Designer" (0xea19 0xea1b 0xea1a) +event_close)

	;toolbar
	(ui-tool-bar toolbar ()
		(ui-button new_btn (:text "New" :min_width 80))
		(ui-button open_btn (:text "Open" :min_width 80))
		(ui-button save_btn (:text "Save" :min_width 80))
		(ui-button save_as_btn (:text "Save As" :min_width 80)))

	;main content area
	(ui-flow main_area (:flow_flags +flow_right_fill)

		;left panel - widget palette
		(ui-flow palette_panel (:flow_flags +flow_down_fill :min_width 200
				:color *env_toolbar2_col*)
			(ui-title palette_title (:text "Palette"))
			(ui-scroll palette_scroll (+scroll_flag_vertical)
				(:min_width 200 :min_height 400)
				(ui-flow palette_flow (:flow_flags +flow_down_fill)
					;widget buttons will be added here
					(each (lambda (widget_type)
						(. (ui-button _ (:text widget_type :min_width 180))
							:connect +event_select_widget))
						+widget-types))))

		;center panel - canvas/preview
		(ui-flow canvas_panel (:flow_flags +flow_down_fill :color +argb_grey10)
			(ui-title canvas_title (:text "Design Surface"))
			(ui-backdrop canvas (:min_width 400 :min_height 500
					:color +argb_white)
				;preview will be rendered here
				))

		;right panel - properties
		(ui-flow props_panel (:flow_flags +flow_down_fill :min_width 250
				:color *env_toolbar2_col*)
			(ui-title props_title (:text "Properties"))
			(ui-scroll props_scroll (+scroll_flag_vertical)
				(:min_width 250 :min_height 300)
				(ui-flow props_flow (:flow_flags +flow_down_fill)
					(ui-label info_label (:text "Select an element"
						:min_width 230))))))

	;bottom panel - tree view
	(ui-flow tree_panel (:flow_flags +flow_down :min_height 200
			:color *env_toolbar2_col*)
		(ui-title tree_title (:text "UI Tree"))
		(ui-scroll tree_scroll (+scroll_flag_vertical)
			(:min_height 150)
			(ui-vdu tree_vdu (:min_width 980 :min_height 140)))))

;connect buttons
(. new_btn :connect +event_new)
(. open_btn :connect +event_open)
(. save_btn :connect +event_save)
(. save_as_btn :connect +event_save_as)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Main Loop
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun display-tree (tree vdu)
	; (display-tree tree vdu) -> :nil
	(when (and tree vdu)
		(.-> vdu :clear)
		(defq lines (tree-to-strings tree))
		(each (lambda (line)
			(. vdu :write line)
			(. vdu :write (ascii-char 10)))
			lines)
		(.-> vdu :layout :dirty)))

(defun main ()
	;initialize
	(bind '(x y w h) (apply view-locate (. *window* :pref_size)))
	(gui-add-front-rpc (. *window* :change x y w h))

	(defq select (task-mboxes +select_size)
		running :t)

	(def *window* :tip_mbox (elem-get select +select_tip))

	;create initial empty design
	(new-design)
	(display-tree *designer-tree* tree_vdu)

	;main event loop
	(while running
		(defq msg (mail-read (elem-get select (defq idx (mail-select select))))
			id (getf msg +ev_msg_target_id))

		(case idx
			(+select_tip
				(if (defq view (. *window* :find_id (getf msg +mail_timeout_id)))
					(. view :show_tip)))

			(+select_main
				(cond
					;window events
					((= id +event_close)
						(setq running :nil))

					((= id +event_min)
						(bind '(x y w h) (apply view-fit
							(cat (. *window* :get_pos) (. *window* :pref_size))))
						(. *window* :change_dirty x y w h))

					((= id +event_max)
						(bind '(x y w h) (apply view-fit
							(cat (. *window* :get_pos) '(1024 768))))
						(. *window* :change_dirty x y w h))

					;file operations
					((= id +event_new)
						(new-design)
						(display-tree *designer-tree* tree_vdu))

					((= id +event_save)
						(if *designer-file*
							(save-design *designer-file*)
							;TODO: show save dialog
							(print "Save As dialog not implemented")))

					((= id +event_save_as)
						;TODO: show save as dialog
						(print "Save As dialog not implemented"))

					((= id +event_open)
						;TODO: show open dialog
						(print "Open dialog not implemented"))

					;widget palette
					((>= id +event_select_widget)
						(defq button (. *window* :find_id (getf msg +ev_msg_action_source_id)))
						(when button
							(defq widget_type (get :text button))
							(when *designer-tree*
								;add to root for now
								(add-element *designer-tree* widget_type)
								(setq *designer-modified* :t)
								(display-tree *designer-tree* tree_vdu))))

					;default event handling
					(:t (. *window* :event msg))))))

	;cleanup
	(gui-sub-rpc *window*))
