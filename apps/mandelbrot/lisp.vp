(include "lib/asm/func.inc")
(include "gui/canvas/class.inc")
(include "class/str/class.inc")
(include "class/real/class.inc")
(include "class/lisp/class.inc")
(include "./app.inc")

(def-func 'apps/mandelbrot/depth)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14, :f0-:f7

	(vp-rdef (this args cnt ox0 oy0))
	(vp-fdef (x0 y0 xc yc x2 y2 four two temp))

	(entry `(,this ,args))

	(errorif-lisp-args-sig 'error :r1 2)

	(vp-push :r0)
	(list-bind-args :r1 `(,ox0 ,oy0) '(:real :real) `(,x0 ,y0))

	(vp-lea-p 'fn_consts cnt)
	(load-fields cnt
		(fn-consts (n2r 4.0) (n2r 2.0))
		`(,four ,two))

	;init i=0, xc=0.0, yc=0.0, x2=0.0, y2=0.0
	(vp-xor-rr cnt cnt)
	(vp-simd vp-sub-ff `(,xc ,yc ,x2 ,y2)  `(,xc ,yc ,x2 ,y2))

	(loop-start)
		(vp-cpy-ff x2 temp)
		(vp-add-ff y2 temp)
		(breakif `(,temp >= ,four))

		; y = 2 * x * y + y0
		(vp-mul-ff two yc)
		(vp-mul-ff xc yc)
		; x = x2 - y2 + x0
		(vp-cpy-ff x2 xc)
		(vp-sub-ff y2 xc)
		(vp-simd vp-add-ff `(,x0 ,y0) `(,xc ,yc))
		; x2 = x * x, y2 = y * y
		(vp-simd vp-cpy-ff `(,xc ,yc) `(,x2 ,y2))
		(vp-simd vp-mul-ff `(,x2 ,y2) `(,x2 ,y2))

		(vp-add-cr 1 cnt)
	(loop-until `(,cnt = 255))

	(call :num :create `(,cnt) '(:r1))
	(vp-pop :r0)

	(exit `(,this ,args))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error '(:r0 "(depth x0 y0)" +error_msg_wrong_types :r1))
	(signature '(:real :real)))

(def-func-end)

(def-func 'apps/mandelbrot/tile)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(ptr this canvas)
		(pubyte data)
		(plong lut)
		(uint x y x1 y1 xp yp))

	(entry '(:r0 :r1))

	(errorif-lisp-args-sig 'error :r1 3)

	(push-scope)
	(assign '(:r0) {this})

	(list-bind-args :r1 '(:r0 :r1 :r2) '(:canvas :str :array))
	(array-get-args :r1 '(:r7 :r8 :r9 :r10) 'ui)
	(vp-add-cr (* 4 +int_size) :r1)
	(assign '((:r2 array_begin)) '(:r2))
	(assign '(:r0 :r1 :r2 :r7 :r8 :r9 :r10 :r8) {canvas, data, lut, x, y, x1, y1, yp})
	(loop-start)
		(assign {x} {xp})
		(loop-start)
			(assign {lut[+long_size * *data]} {canvas->canvas_color})
			(call :canvas :plot {canvas, xp, yp})
			(assign {data + +byte_size} {data})
		(loop-until {(xp + 1 => xp) = x1})
	(loop-until {(yp + 1 => yp) = y1})

	(call :num :create {(x1 - x) * (y1 - y)} '(:r1))

	(assign {this} '(:r0))
	(exit '(:r0 :r1))
	(pop-scope)
	(return)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error '(:r0 "(tile canvas data lut)" +error_msg_wrong_types :r1))
	(signature '(:canvas :str :array)))

(def-func-end)
