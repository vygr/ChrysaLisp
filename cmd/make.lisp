(import "lib/asm/asm.inc")
(import "lib/task/pipe.inc")
(import "lib/options/options.inc")

(defun make-docs ()
	(defq *abi* (abi) *cpu* (cpu))
	(defun chop (_)
		(when (defq e (find-rev (char 0x22) _))
			(setq _ (slice 0 e _))
			(slice (inc (find-rev (char 0x22) _)) -1 _)))
	(print "Scanning source files...")
	(defq *imports* (all-vp-files) classes (list) functions (list) docs (list) syntax (list) state :x)
	(within-compile-env (lambda ()
		(include "sys/func.inc")
		(each include (all-class-files))
		(each-mergeable (lambda (file)
			(each-line (lambda (line)
				(when (eql state :y)
					(defq s (split line (const (cat (ascii-char 9) " "))))
					(if (and (> (length s) 0) (starts-with ";" (elem-get 0 s)))
						(push (elem-get -2 docs) (slice (inc (find ";" line)) -1 line))
						(setq state :x)))
				(when (and (eql state :x) (>= (length line) 9))
					(defq s (split line (const (cat (ascii-char 9) " ()'" (ascii-char 34) (ascii-char 13)))) _ (elem-get 0 s))
					(cond
						((eql _ "include")
							(make-merge *imports* (list (abs-path (elem-get 1 s) file))))
						((eql _ "def-class")
							(push classes (list (elem-get 1 s) (elem-get 2 s))))
						((eql _ "dec-method")
							(push (elem-get -2 classes) (list (elem-get 1 s) (sym (elem-get 2 s)))))
						((eql _ "def-method")
							(setq state :y)
							(push docs (list))
							(push functions (f-path (sym (elem-get 1 s)) (sym (elem-get 2 s)))))
						((or (eql _ "def-func") (eql _ "defun"))
							(setq state :y)
							(push docs (list))
							(push functions (sym (elem-get 1 s))))
						((and (or (eql _ "call") (eql _ "jump")) (eql (elem-get 2 s) ":repl_error"))
							(if (setq line (chop line))
								(merge-obj syntax (list (sym line)))))))) (file-stream file))) *imports*)))
	;create classes docs
	(sort (# (cmp (elem-get 0 %0) (elem-get 0 %1))) classes)
	(defq stream (file-stream "docs/VP_CLASSES.md" +file_open_write)
		classes (map (lambda ((a b &rest c))
			(sort (# (cmp (elem-get 0 %0) (elem-get 0 %1))) c)
			(cat (list a b) c)) classes))
	(write-line stream (const (str "# VP Classes" (ascii-char 10))))
	(each (lambda ((cls super &rest methds))
		(write-line stream (cat "## " cls (ascii-char 10)))
		(write-line stream (cat "Super Class: " super (ascii-char 10)))
		(each (lambda ((methd function))
			(write-line stream (cat "### " cls " " methd " -> " function (ascii-char 10)))
			(when (and (defq i (find function functions)) (/= 0 (length (elem-get i docs))))
				(write-line stream "```code")
				(each (# (write-line stream %0)) (elem-get i docs))
				(write-line stream (const (str "```" (ascii-char 10)))))) methds)) classes)
	(print "-> docs/VP_CLASSES.md")

	;create commands docs
	(defq target 'docs/COMMANDS.md)
	(defun extract-cmd (el)
		(first (split (second (split el "/")) ".")))
	(defun cmd-collector (acc el)
		(push acc (list (sym el) (str el " -h"))))
	(defun wrap-block (content)
		(if (/= (length content) 0)
			(str
				"```code" (ascii-char 10)
				content (ascii-char 10)
				"```" (ascii-char 10))
			""))
	(defun generate-cmd-help (lst)
		(defq _eat_chunk "")
		(defun _eat (_x)
		(setq _eat_chunk (cat _eat_chunk (wrap-block _x))))
		(each (lambda (el)
		(setq _eat_chunk (cat _eat_chunk (str "## " (first el) (const (ascii-char 10)))))
		(pipe-run (second el) _eat)) lst)
		(save _eat_chunk target))
	(generate-cmd-help (reduce
		cmd-collector
		(sort cmp (map extract-cmd (all-files "cmd" ".lisp")))
		(list)))
	(print "-> docs/COMMANDS.md")

	;create lisp syntax docs
	(each (lambda (file)
		(each-line (lambda (line)
			(when (eql state :y)
				(defq s (split line (const (cat (ascii-char 9) " "))))
				(if (and (> (length s) 1) (starts-with ";" (elem-get 0 s)) (starts-with "(" (elem-get 1 s)))
					(merge-obj syntax (list (sym (slice (find "(" line) -1 line))))
					(setq state :x)))
			(when (and (eql state :x) (> (length line) 9))
				(defq _ (elem-get 0 (split line (const (cat (ascii-char 9) " ()'" (ascii-char 13))))))
				(cond
					((or (eql _ "defun") (eql _ "defmacro") (eql _ "defclass")
							(eql _ "defmethod") (eql _ "deffimethod") (eql _ "defabstractmethod"))
						(setq state :y))))) (file-stream file)))
		(cat (all-files "." "lisp.inc")
			'("class/lisp/boot.inc" "lib/anaphoric/anaphoric.inc" "lib/debug/debug.inc"
			"lib/debug/profile.inc" "lib/collections/xmap.inc" "lib/collections/xset.inc"
			"lib/collections/emap.inc" "lib/collections/collections.inc" "lib/class/class.inc"
			"lib/class/struct.inc" "lib/text/buffer.inc" "lib/text/syntax.inc" "apps/debug/app.inc"
			"lib/task/pipe.inc" "lib/task/global.inc" "lib/task/farm.inc"
			"lib/text/dictionary.inc")))
	(sort cmp syntax)
	(defq stream (file-stream "docs/SYNTAX.md" +file_open_write))
	(write-line stream (const (str "# Syntax" (ascii-char 10))))
	(each (lambda (line)
		(defq form (elem-get 0 (defq body (split line (const (cat (ascii-char 9) " )"))))))
		(cond
			((and (starts-with "(." form) (eql (elem-get 1 body) "this"))
				(write-line stream (cat "### " (slice 1 -1 form) (ascii-char 10)))
				(write-line stream "```code")
				(write-line stream line)
				(write-line stream (cat "```" (ascii-char 10))))
			((starts-with "(." form)
				(write-line stream (cat "### " (elem-get 1 body) " " (elem-get 2 body) (ascii-char 10)))
				(write-line stream "```code")
				(write-line stream line)
				(write-line stream (cat "```" (ascii-char 10))))
			((starts-with "(" form)
				(write-line stream (cat "### " (slice 1 -1 form) (ascii-char 10)))
				(write-line stream "```code")
				(write-line stream line)
				(write-line stream (cat "```" (ascii-char 10)))))) syntax)
	(print "-> docs/SYNTAX.md"))

(defq usage `(
(("-h" "--help")
"Usage: make [options] [all] [boot] [platforms] [doc] [it]
	options:
		-h --help: this help info.
	all: include all .vp files.
	boot: create a boot image.
	platforms: for all platforms not just the host.
	docs: scan source files and create documentation.
	it: all of the above !")
))

(defun main ()
	;initialize pipe details and command args, abort on error
	(when (and
			(defq stdio (create-stdio))
			(defq args (options stdio usage)))
		(defq all (find-rev "all" args) boot (find-rev "boot" args)
			platforms (find-rev "platforms" args) docs (find-rev "docs" args) it (find-rev "it" args))
		(cond
			(it (make-docs) (remake-all-platforms))
			((and boot all platforms) (remake-all-platforms))
			((and boot all) (remake-all))
			((and boot platforms) (remake-platforms))
			((and all platforms) (make-all-platforms))
			(all (make-all))
			(platforms (make-platforms))
			(boot (remake))
			(docs (make-docs))
			(t (make)))))
