(include "lib/asm/func.inc")
(include "./class.inc")
(include "././statics/class.inc")

(def-method 'sys_math :i_rand)
	;inputs
	;:r0 = random range (ulong)
	;outputs
	;:r0 = random number in range (ulong)
	;trashes
	;:r0-:r3

	(entry 'sys_math :i_rand '(:r0))

	(vpif '(:r0 /= 0))
		(fn-bind 'sys/statics/statics :r3)
		(vp-cpy-rr :r0 :r1)
		(vp-cpy-ir :r3 statics_sys_math_seed :r0)
		(vpif '(:r0 = 0))
			;total random at start up
			(vp-cpy-rr :r1 :r2)
			(call 'host_os :pii_rand '((& :r3 statics_sys_math_seed) +long_size))
			(vp-cpy-ir :r3 statics_sys_math_seed :r0)
			(vp-cpy-rr :r2 :r1)
		(endif)
		(vp-cpy-rr :r0 :r2)
		(vp-shl-cr 21 :r2)
		(vp-xor-rr :r2 :r0)
		(vp-cpy-rr :r0 :r2)
		(vp-asr-cr 35 :r2)
		(vp-xor-rr :r2 :r0)
		(vp-cpy-rr :r0 :r2)
		(vp-shl-cr 4 :r2)
		(vp-xor-rr :r2 :r0)
		(vp-cpy-ri :r0 :r3 statics_sys_math_seed)
		(vp-xor-rr :r2 :r2)
		(vp-div-rrr-u :r1 :r2 :r0)
		(vp-cpy-rr :r2 :r0)
	(endif)

	(exit 'sys_math :i_rand '(:r0))
	(vp-ret)

(def-func-end)

(def-method 'sys_math :f_sqrt)
	;inputs
	;:r0 = number (fixed)
	;outputs
	;:r0 = sqrt (fixed)
	;trashes
	;:r0-:r1, :f0-:f1

	(entry 'sys_math :f_sqrt '(:r0))

	(vp-lea-p 'fn_consts :r1)
	(assign '((:r1 (fn-const (recip (n2r (<< 1 +fp_shift)))))) '(:f0))
	(vp-cvt-rf :r0 :f1)
	(vp-mul-ff :f0 :f1)
	(vp-sqrt-ff :f1 :f1)
	(assign '((:r1 (fn-const (n2r (<< 1 +fp_shift))))) '(:f0))
	(vp-mul-ff :f1 :f0)
	(vp-cvt-fr :f0 :r0)

	(exit 'sys_math :f_sqrt '(:r0))
	(vp-ret)

(def-func-end)

(def-method 'sys_math :f_sin)
	;inputs
	;:r0 = angle in radians (fixed)
	;outputs
	;:r0 = sin (fixed)
	;trashes
	;:r0-:r2, :f0-:f3

	(entry 'sys_math :f_sin '(:r0))

	(vp-lea-p 'fn_consts :r2)
	(assign '((:r2 (fn-const (recip (n2r (<< 1 +fp_shift)))))) '(:f0))
	(vp-cvt-rf :r0 :f1)
	(vp-mul-ff :f1 :f0)
	(call 'sys_math :r_sin '(:f0) '(:f0))
	(assign '((:r2 (fn-const (n2r (<< 1 +fp_shift))))) '(:f1))
	(vp-mul-ff :f1 :f0)
	(vp-cvt-fr :f0 :r0)

	(exit 'sys_math :f_sin '(:r0))
	(vp-ret)

(def-func-end)

(def-method 'sys_math :f_cos)
	;inputs
	;:r0 = angle in radians (fixed)
	;outputs
	;:r0 = cos (fixed)
	;trashes
	;:r0-:r2, :f0-:f3

	(entry 'sys_math :f_cos '(:r0))

	(vp-lea-p 'fn_consts :r2)
	(assign '((:r2 (fn-const (recip (n2r (<< 1 +fp_shift)))))) '(:f0))
	(vp-cvt-rf :r0 :f1)
	(vp-mul-ff :f1 :f0)
	(assign '((:r2 (fn-const 0x3ff921fb54442d18))) '(:f1))
	(vp-add-ff :f1 :f0)
	(call 'sys_math :r_sin '(:f0) '(:f0))
	(assign '((:r2 (fn-const (n2r (<< 1 +fp_shift))))) '(:f1))
	(vp-mul-ff :f1 :f0)
	(vp-cvt-fr :f0 :r0)

	(exit 'sys_math :f_cos '(:r0))
	(vp-ret)

(def-func-end)

(def-method 'sys_math :r_sin)
	;inputs
	;:f0 = real (real)
	;outputs
	;:f0 = real (real)
	;trashes
	;:r0-:r1, :f0-:f3

	(entry 'sys_math :r_sin '(:f0))

	(vp-lea-p 'constants :r0)

	; --- Range Reduction: fmod(x, 2pi) ---
	(vp-cpy-if :r0 0 :f2)       ; Load 1/2pi
	(vp-cpy-ff :f0 :f1)         ; f0 = x
	(vp-mul-ff :f2 :f0)         ; f0 = x / 2pi
	(vp-cvt-fr :f0 :r1)         ; r1 = (int)(x / 2pi)
	(vp-cvt-rf :r1 :f2)         ; f2 = (double)k
	(vp-cpy-if :r0 8 :f3)       ; Load 2pi
	(vp-mul-ff :f3 :f2)         ; f2 = k * 2pi
	(vp-sub-ff :f2 :f1)         ; f1 = x - k*2pi

	; --- Symmetry to [-pi, pi] ---
	(vp-cpy-if :r0 16 :f2)      ; Load pi
	(vp-cpy-ff :f2 :f3)         ; f3 = pi
	(vp-neg-ff :f2 :f2)         ; f2 = -pi

	(vp-bgt-ff :f3 :f1 'sub_2pi)
	(vp-blt-ff :f2 :f1 'add_2pi)
	(vp-jmp 'check_hpi)

(vp-label 'sub_2pi)
	(vp-cpy-if :r0 8 :f2)       ; Load 2pi
	(vp-sub-ff :f2 :f1)         ; x -= 2pi
	(vp-jmp 'check_hpi)

(vp-label 'add_2pi)
	(vp-cpy-if :r0 8 :f2)       ; Load 2pi
	(vp-add-ff :f2 :f1)         ; x += 2pi

	; --- Symmetry to [-pi/2, pi/2] ---
(vp-label 'check_hpi)
	(vp-cpy-if :r0 24 :f2)      ; Load pi/2
	(vp-cpy-ff :f2 :f3)         ; f3 = pi/2
	(vp-neg-ff :f2 :f2)         ; f2 = -pi/2

	(vp-bgt-ff :f3 :f1 'fold_pos)
	(vp-blt-ff :f2 :f1 'fold_neg)
	(vp-jmp 'poly)

(vp-label 'fold_pos)
	(vp-cpy-if :r0 16 :f2)      ; Load pi
	(vp-sub-ff :f1 :f2)         ; f2 = pi - x
	(vp-cpy-ff :f2 :f1)
	(vp-jmp 'poly)

(vp-label 'fold_neg)
	(vp-cpy-if :r0 16 :f2)      ; Load pi
	(vp-neg-ff :f2 :f2)         ; f2 = -pi
	(vp-sub-ff :f1 :f2)         ; f2 = -pi - x
	(vp-cpy-ff :f2 :f1)

	; --- Polynomial Approximation (Taylor) ---
(vp-label 'poly)
	(vp-cpy-ff :f1 :f3)
	(vp-mul-ff :f1 :f3)         ; f3 = x^2

	; Horner's Method
	(vp-cpy-if :r0 80 :f0)      ; Load c7
	(vp-mul-ff :f3 :f0)
	(vp-cpy-if :r0 72 :f2)      ; Load c6
	(vp-add-ff :f2 :f0)
	(vp-mul-ff :f3 :f0)
	(vp-cpy-if :r0 64 :f2)      ; Load c5
	(vp-add-ff :f2 :f0)
	(vp-mul-ff :f3 :f0)
	(vp-cpy-if :r0 56 :f2)      ; Load c4
	(vp-add-ff :f2 :f0)
	(vp-mul-ff :f3 :f0)
	(vp-cpy-if :r0 48 :f2)      ; Load c3
	(vp-add-ff :f2 :f0)
	(vp-mul-ff :f3 :f0)
	(vp-cpy-if :r0 40 :f2)      ; Load c2
	(vp-add-ff :f2 :f0)
	(vp-mul-ff :f3 :f0)
	(vp-cpy-if :r0 32 :f2)      ; Load c1
	(vp-add-ff :f2 :f0)
	(vp-mul-ff :f3 :f0)
	(vp-cpy-if :r0 88 :f2)      ; Load 1.0
	(vp-add-ff :f2 :f0)
	(vp-mul-ff :f1 :f0)

	(exit 'sys_math :r_sin '(:f0))
	(vp-ret)

(vp-align 8)
(vp-label 'constants)
	(vp-long 0x3fc45f306dc9c883) ;  0: 1 / 2pi
	(vp-long 0x401921fb54442d18) ;  8: 2pi
	(vp-long 0x400921fb54442d18) ; 16: pi
	(vp-long 0x3ff921fb54442d18) ; 24: pi / 2
	(vp-long 0xbfc5555555555555) ; 32: c1 (-1/6)
	(vp-long 0x3f81111111111111) ; 40: c2 (1/120)
	(vp-long 0xbf2a01a01a01a01a) ; 48: c3 (-1/5040)
	(vp-long 0x3ec71de3a556c734) ; 56: c4 (1/362880)
	(vp-long 0xbe5ae64567f544e4) ; 64: c5 (-1/39916800)
	(vp-long 0x3de6124613a86d09) ; 72: c6 (1/6227020800)
	(vp-long 0xbceae73673322e72) ; 80: c7 (-1/1.307e12)
	(vp-long 0x3ff0000000000000) ; 88: 1.0

(def-func-end)

(def-method 'sys_math :f_intersect)
	;inputs
	;:r0 = p1x (fixed)
	;:r1 = p1y (fixed)
	;:r2 = p2x (fixed)
	;:r3 = p2y (fixed)
	;:r4 = v1x (fixed)
	;:r5 = v1y (fixed)
	;:r6 = v2x (fixed)
	;:r7 = v2y (fixed)
	;outputs
	;:r0 = ix (fixed)
	;:r1 = iy (fixed)
	;trashes
	;:r0-:r14

	(vec-set 8)
	(entry 'sys_math :f_intersect (vec-top 8))

	(bind '(p1x p1y p2x p2y v1x v1y v2x v2y) (vec-top 8))
	(defq p1 (list p1x p1y) p2 (list p2x p2y)
		v1 (list v1x v1y) v2 (list v2x v2y))
	(bind '(v1x v1y) (map (const list) v1))
	(bind '(v2x v2y) (map (const list) v2))

	(vec-dup 2 v2)
	(vec-dup 2 p2)
	(vec-add 2)
	(vec-dup 2 p2)
	(vec-fdet 2)
	(defq db (vec-top 1))

	(vec-dup 2 v1)
	(vec-dup 2 p1)
	(vec-add 2)
	(vec-dup 2 p1)
	(vec-fdet 2)
	(defq da (vec-top 1))

	(vec-dup 2 v1)
	(vec-dup 2 v2)
	(vec-fdet 2)
	(defq axb (vec-top 1))

	(vpif (list (first axb) '/= 0))
		(vec-dup 2 (cat da v1x))
		(vec-fdet 2 (cat db v2x))
		(vec-dup 2 (cat da v1y))
		(vec-fdet 2 (cat db v2y))
		(vec-fdiv 2 (cat axb axb))
		(exit 'sys_math :f_intersect (vec-pop 2))
	(else)
		(vec-set 4)
		(vec-add 2)
		(vec-load 1 {0.5})
		(vec-fscale 2)
		(exit 'sys_math :f_intersect (vec-pop 2))
	(endif)
	(vp-ret)

(def-func-end)

(def-method 'sys_math :f_dist_sqd)
	;inputs
	;:r0 = px (fixed)
	;:r1 = py (fixed)
	;:r2 = p1x (fixed)
	;:r3 = p1y (fixed)
	;:r4 = p2x (fixed)
	;:r5 = p2y (fixed)
	;outputs
	;:r0 = distance squared (fixed)
	;trashes
	;:r0-:r14

	(def-vars
		(int px py p1x p1y p2x p2y))

	(push-scope)
	(entry 'sys_math :f_dist_sqd {px, py, p1x, p1y, p2x, p2y})

	(vec-set 0)
	(vec-load 2 {px, py})
	(defq p (vec-top 2))
	(vec-load 2 {p1x, p1y})
	(defq p1 (vec-top 2))
	(vec-load 2 {p2x, p2y})
	(defq p2 (vec-top 2))

	(vec-dup 2)
	(vec-sub 2 p1)
	(defq lv (vec-top 2))

	(vec-dup 2 p)
	(vec-sub 2 p1)
	(vec-fdot 2 lv)
	(bind '(c1) (vec-top 1))

	(vpif `(,c1 > 0))
		(vec-dup 2 lv)
		(vec-fdot 2 lv)
		(bind '(c2) (vec-top 1))

		(vpif `(,c2 <= ,c1))
			(vec-cpy 2 p2 p1)
		(else)
			(vec-fdiv 1)
			(vec-fscale 2)
			(vec-add 2 lv p1)
		(endif)
	(endif)
	(vec-set 4)
	(vec-fdistance-squared 2)

	(exit 'sys_math :f_dist_sqd (vec-pop 1))
	(pop-scope)
	(return)

(def-func-end)
