(include "lib/asm/func.inc")
(include "lib/consts/chars.inc")
(include "././sym/class.inc")
(include "././stream/class.inc")
(include "././num/class.inc")
(include "././list/class.inc")

(gen-create1 :array)
(gen-vtable :array)
(gen-type :array)

(def-method :array :deinit)
	;inputs
	;:r0 = array object (ptr)
	;outputs
	;:r0 = array object (ptr)
	;trashes
	;:r1-:r14

	(entry :array :deinit '(:r0))

	;free any dynamic array
	(assign '((:r0 +array_begin) (& :r0 +array_elems)) '(:r2 :r1))
	(vpif '(:r2 /= :r1))
		(vp-cpy-rr :r0 :r3)
		(call :sys_mem :free '(:r2))
		(vp-cpy-rr :r3 :r0)
	(endif)
	(s-jump :array :deinit '(:r0))

(def-func-end)

(def-method :array :clear)
	;inputs
	;:r0 = array object (ptr)
	;outputs
	;:r0 = array object (ptr)
	;trashes
	;:r1

	(entry :array :clear '(:r0))

	(class/array/clear)

	(exit :array :clear '(:r0))
	(vp-ret)

(def-func-end)

(def-method :array :find)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = element (long)
	;:r2 = start index (uint)
	;outputs
	;:r0 = array object (ptr)
	;:r1 = element (long)
	;:r2 = -1, else index (int)
	;trashes
	;:r2-:r4

	(vp-rdef (this elm idx base tmp))

	(entry :array :find `(,this ,elm ,idx))

	(assign `((,this +array_length) (,this +array_begin)) `(,tmp ,base))
	(vp-simd vp-shl-cr `(,(log2 +long_size)) `(,idx ,tmp))
	(vp-add-rr base idx)
	(vp-add-rr tmp base)
	(vpif `(,idx /= ,base))
		(loop-start)
			(assign `((,idx 0)) `(,tmp))
			(vp-add-cr +long_size idx)
			(gotoif `(,elm = ,tmp) 'found)
		(loop-until `(,idx = ,base))
	(endif)

	(exit :array :find `(,this ,elm -1))
	(vp-ret)

(vp-label 'found)
	(assign `((,this +array_begin)) `(,base))
	(vp-sub-cr +long_size idx)
	(vp-sub-rr base idx)
	(vp-shr-cr (log2 +long_size) idx)

	(exit :array :find `(,this ,elm ,idx))
	(vp-ret)

(def-func-end)

(def-method :array :rfind)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = element (long)
	;:r2 = start index (uint)
	;outputs
	;:r0 = array object (ptr)
	;:r1 = element (long)
	;:r2 = 0, else index (int)
	;trashes
	;:r2-:r4

	(vp-rdef (this elm idx base tmp))

	(entry :array :rfind `(,this ,elm ,idx))

	(assign `((,this +array_begin)) `(,base))
	(vp-shl-cr (log2 +long_size) idx)
	(vp-add-rr base idx)
	(vpif `(,idx /= ,base))
		(loop-start)
			(assign `((,idx ,(neg +long_size))) `(,tmp))
			(breakif `(,elm = ,tmp))
			(vp-sub-cr +long_size idx)
		(loop-until `(,idx = ,base))
	(endif)
	(vp-sub-rr base idx)
	(vp-asr-cr (log2 +long_size) idx)

	(exit :array :rfind `(,this ,elm ,idx))
	(vp-ret)

(def-func-end)

(def-method :array :get_length)
	;inputs
	;:r0 = array object (ptr)
	;outputs
	;:r0 = array object (ptr)
	;:r1 = array length (uint)
	;trashes
	;:r1

	(entry :array :get_length '(:r0))

	(class/array/get_length)

	(exit :array :get_length '(:r0 :r1))
	(vp-ret)

(def-func-end)

(def-method :array :push_back)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = element (long)
	;outputs
	;:r0 = array object (ptr)
	;:r1 = element (long)
	;:r2 = begin element iter (plong)
	;:r3 = end element iter (plong)
	;trashes
	;:r2-:r5

	(entry :array :push_back '(:r0 :r1))

	;increase capacity ?
	(assign '((:r0 +array_length) (:r0 +array_capacity)) '(:r3 :r2))
	(vp-add-cr 1 :r3)
	(assign '(:r3) '((:r0 +array_length)))
	(vpif '(:r3 > :r2))
		;double the capacity
		(vp-add-rr :r2 :r2)
		(vp-push :r1)
		(call :array :set_cap '(:r0 :r2) '(:r0))
		(assign '((:r0 +array_length)) '(:r3))
		(vp-pop :r1)
	(endif)

	;save object
	(class/array/get_iter :r0 :r3 :r2)
	(assign '(:r1) `((:r3 ,(neg +long_size))))

	(exit :array :push_back '(:r0 :r1 :r2 :r3))
	(vp-ret)

(def-func-end)

(def-method :array :push_back2)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = element1 (long)
	;:r2 = element2 (long)
	;outputs
	;:r0 = array object (ptr)
	;:r1 = element1 (long)
	;:r2 = element2 (long)
	;:r3 = begin element iter (plong)
	;:r4 = end element iter (plong)
	;trashes
	;:r3-:r5

	(entry :array :push_back2 '(:r0 :r1 :r2))

	;increase capacity ?
	(assign '((:r0 +array_length) (:r0 +array_capacity)) '(:r4 :r3))
	(vp-add-cr 2 :r4)
	(assign '(:r4) '((:r0 +array_length)))
	(vpif '(:r4 > :r3))
		;double the capacity
		(vp-add-rr :r3 :r3)
		(vp-push :r1 :r2)
		(call :array :set_cap '(:r0 :r3) '(:r0))
		(assign '((:r0 +array_length)) '(:r4))
		(vp-pop :r1 :r2)
	(endif)

	;save object
	(class/array/get_iter :r0 :r4 :r3)
	(assign '(:r1 :r2) `((:r4 ,(* -2 +long_size)) (:r4 ,(neg +long_size))))

	(exit :array :push_back2 '(:r0 :r1 :r2 :r3 :r4))
	(vp-ret)

(def-func-end)

(def-method :array :ref_back)
	;inputs
	;:r0 = array object (ptr)
	;outputs
	;:r0 = array object (ptr)
	;:r1 = num object (ptr)
	;trashes
	;:r1-:r3

	(entry :array :ref_back '(:r0))

	(assign '((:r0 +array_length) (:r0 +array_begin)) '(:r1 :r2))
	(vp-sub-cr 1 :r1)
	(assign '(:r1) '((:r0 +array_length)))
	(vp-shl-cr (log2 +long_size) :r1)
	(vp-cpy-rr :r0 :r3)
	(v-call :array :velement '((:r2 :r1)) '(:r0) :r3 :r1)

	(exit :array :ref_back '(:r3 :r0))
	(vp-ret)

(def-func-end)

(def-method :array :ref_elem)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = element index (uint)
	;outputs
	;:r0 = array object (ptr)
	;:r1 = num object (ptr)
	;trashes
	;:r1-:r3

	(entry :array :ref_elem '(:r0 :r1))

	(vp-cpy-rr :r0 :r3)
	(class/array/get_elem :r0 :r1 :r0 :r0)
	(v-call :array :velement '(:r0) '(:r0) :r3 :r1)

	(exit :array :ref_elem '(:r3 :r0))
	(vp-ret)

(def-func-end)

(def-method :array :set_cap)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = capacity (uint)
	;outputs
	;:r0 = array object (ptr)
	;trashes
	;:r1-:r5

	(entry :array :set_cap '(:r0 :r1))

	;do we already have room ?
	(assign '((:r0 +array_capacity)) '(:r2))
	(vpif '(:r1 > :r2))
		;realloc the dynamic array
		(vp-push :r0)
		(assign '((& :r0 +array_elems) (:r0 +array_begin)) '(:r3 :r0))
		(vp-shl-cr (log2 +long_size) :r1)
		(vpif '(:r0 = :r3))
			(call :sys_mem :alloc '(:r1) '(:r1 :r2))
			(vp-pop :r0)
			;transfer local elements
			(each (lambda ((e0 &optional e1 e2))
					(vp-cpy-ir :r0 e0 :r3)
					(if e1 (vp-cpy-ir :r0 e1 :r4))
					(if e2 (vp-cpy-ir :r0 e2 :r5))
					(vp-cpy-ri :r3 :r1 (- e0 +array_elems))
					(if e1 (vp-cpy-ri :r4 :r1 (- e1 +array_elems)))
					(if e2 (vp-cpy-ri :r5 :r1 (- e2 +array_elems))))
				(partition (range +array_elems +array_size +long_size) 3))
		(else)
			(vp-shl-cr (log2 +long_size) :r2)
			(vp-swp-rr :r1 :r2)
			(call :sys_mem :realloc '(:r0 :r1 :r2) '(:r1 :r2))
			(vp-pop :r0)
		(endif)
		(vp-shr-cr (log2 +long_size) :r2)
		(assign '(:r1 :r2) '((:r0 +array_begin) (:r0 +array_capacity)))
	(endif)

	(exit :array :set_cap '(:r0))
	(vp-ret)

(def-func-end)

(def-method :array :set_elem)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = element object (ptr)
	;:r2 = element index (uint)
	;outputs
	;:r0 = array object (ptr)
	;trashes
	;:r2-:r3

	(entry :array :set_elem '(:r0 :r1 :r2))

	(class/array/set_elem)

	(exit :array :set_elem '(:r0))
	(vp-ret)

(def-func-end)

(def-method :array :pivot)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = lower partition iter (plong)
	;:r2 = upper partition iter (plong)
	;:r3 = sort callback (ptr)
	;:r4 = sort context (ptr)
	;outputs
	;:r0 = array object (ptr)
	;:r1 = partition iter (plong)
	;trashes
	;:r1-:r14
		;sort callback
		;inputs
		;:r0 = sort context (ptr)
		;:r1 = iter1 (plong)
		;:r2 = iter2 (plong)
		;outputs
		;:r0 = +, 0, -
		;trashes
		;:r1-:r14

	(def-struct local 0
		(ptr this func ctx pivot iter lower upper))

	(vp-alloc local_size)
	(entry :array :pivot '(:r0 :r1 :r2 :r3 :r4))
	(save-fields :rsp
		'(local_this local_lower local_upper local_func local_ctx local_pivot)
		'(:r0 :r1 :r2 :r3 :r4 :r1))

	;pivot selection: swap middle to first (lower) to avoid O(n^2) on sorted data
	(vp-cpy-rr :r2 :r6)
	(vp-sub-rr :r1 :r6)
	(vp-shr-cr 1 :r6)
	(vp-and-cr -8 :r6)
	(vpif '(:r6 /= 0))
		(vp-add-rr :r1 :r6)
		(vp-simd vp-cpy-ir '(:r1 :r6) '(0) '(:r8 :r9))
		(vp-simd vp-cpy-ri '(:r8 :r9) '(:r6 :r1) '(0))
	(endif)

	(loop-start)
		(vp-add-cr +long_size :r1)
		(breakif '(:r1 >= :r2))
		(assign '((:rsp local_ctx) (:rsp local_lower) :r1) '(:r0 :r2 (:rsp local_iter)))
		(vp-call-i :rsp local_func)
		(assign '((:rsp local_iter) (:rsp local_upper)) '(:r1 :r2))
		(continueif '(:r0 >= 0))
		(assign '((:rsp local_pivot)) '(:r0))
		(vp-add-cr +long_size :r0)
		(assign '(:r0) '((:rsp local_pivot)))
		(continueif '(:r0 = :r1))
		(assign '((:r0 0) (:r1 0)) '(:r3 :r4))
		(assign '(:r3 :r4) '((:r1 0) (:r0 0)))
	(loop-end)
	(assign '((:rsp local_pivot) (:rsp local_lower)) '(:r1 :r0))
	(vpif '(:r1 /= :r0))
		(assign '((:r0 0) (:r1 0)) '(:r2 :r3))
		(assign '(:r2 :r3) '((:r1 0) (:r0 0)))
	(endif)

	(exit :array :pivot '((:rsp local_this) :r1))
	(vp-free local_size)
	(vp-ret)

(def-func-end)

(def-method :array :sort)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = stack array object (ptr)
	;:r2 = lower iter (plong)
	;:r3 = upper iter (plong)
	;:r4 = compare callback (ptr)
	;:r5 = sort context (ptr)
	;outputs
	;:r0 = array object (ptr)
	;trashes
	;:r1-:r14
		;sort callback
		;inputs
		;:r0 = context (ptr)
		;:r1 = iter1 (plong)
		;:r2 = iter2 (plong)
		;outputs
		;:r0 = +, 0, -
		;trashes
		;:r1-:r14

	(def-vars
		(ptr this func ctx stack)
		(pptr pivot iter_begin)
		(union
			(uint low high)
			(long interval))
		(union
			(pptr lower upper)
			(uint start length)))

	(push-scope)
	(entry :array :sort {this, stack, lower, upper, func, ctx})

	(call :array :get_begin {this} {_, iter_begin})
	(assign {(lower - iter_begin) >> 3, (upper - iter_begin) >> 3} {low, high})
	(d-call :array :get_length {stack} {_, start})
	(loop-start)
		(vpif {low < high})
			(call :array :pivot {this, low * +long_size + iter_begin, high * +long_size + iter_begin, func, ctx}
				{_, pivot})
			(assign {high} {length})
			(assign {(pivot - iter_begin) >> 3} {high})
			(call :array :push_back {stack, interval})
			(assign {high + 1, length} {low, high})
			(call :array :push_back {stack, interval})
		(endif)
		(d-call :array :get_length {stack} {_, length})
		(breakif {length = start})
		(call :array :pop_back {stack} {_, interval})
	(loop-end)

	(exit :array :sort {this})
	(pop-scope)
	(return)

(def-func-end)

(def-method :array :append)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = source array object (ptr)
	;:r2 = element start index (uint)
	;:r3 = element end index (uint)
	;outputs
	;:r0 = array object (ptr)
	;trashes
	;:r1-:r9

	;save inputs
	(entry :array :append '(:r0 :r1 :r2 :r3))

	(vpif '(:r2 /= :r3))
		;save inputs
		(assign '(:r1 :r2 :r3) '(:r6 :r7 :r8))

		;extend array
		(assign '((:r0 +array_length)) '(:r9))
		(vp-sub-rr :r2 :r3)
		(assign '((& :r3 :r9)) '(:r1))
		(assign '(:r1) '((:r0 +array_length)))
		(call :array :set_cap '(:r0 :r1) '(:r0))

		;append elements
		(class/array/get_iters :r6 :r7 :r8 :r1)
		(class/array/get_iter :r0 :r9 :r1)
		(loop-start)
			(assign '((:r7 0)) '(:r1))
			(vp-simd vp-add-cr `(,+ptr_size) '(:r9 :r7))
			(assign '(:r1) `((:r9 ,(neg +ptr_size))))
		(loop-until '(:r7 = :r8))
	(endif)

	(exit :array :append '(:r0))
	(vp-ret)

(def-func-end)

(def-method :array :print)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = stream object (ptr)
	;outputs
	;:r0 = array object (ptr)
	;trashes
	;:r1-:r14

	(def-struct local 0
		(ptr this stream)
		(plong iter_begin iter_end))

	(vp-alloc local_size)
	(entry :array :print '(:r0 :r1))
	(assign '(:r0 :r1) '((:rsp local_this) (:rsp local_stream)))

	(call :stream :write_char '(:r1 +char_lrb))
	(call :array :get_both '((:rsp local_this)) '(_ :r1 :r2))
	(vpif '(:r1 /= :r2))
		(assign '(:r1 :r2) '((:rsp local_iter_begin) (:rsp local_iter_end)))
		(loop-start)
			(vp-cpy-ir :r1 0 :r0)
			(assign '((:rsp local_this)) '(:r1))
			(v-call :array :velement '(:r0) '(:r0) :r1 :r1)
			(call :num :print '(:r0 (:rsp local_stream)) '(:r0))
			(call :num :deref '(:r0))
			(assign '((:rsp local_iter_begin) (:rsp local_iter_end)) '(:r1 :r2))
			(vp-add-cr +long_size :r1)
			(breakif '(:r1 = :r2))
			(assign '(:r1) '((:rsp local_iter_begin)))
			(call :stream :write_char '((:rsp local_stream) +char_space))
			(assign '((:rsp local_iter_begin)) '(:r1))
		(loop-end)
	(endif)
	(call :stream :write_char '((:rsp local_stream) +char_rrb))

	(exit :array :print '((:rsp local_this)))
	(vp-free local_size)
	(vp-ret)

(def-func-end)

(def-method :array :erase)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = element iterator (pptr)
	;outputs
	;:r0 = array object (ptr)
	;:r1 = element iterator (pptr)
	;trashes
	;:r2-:r3

	(entry :array :erase '(:r0 :r1))

	;swap last entry for erased entry
	(assign '((:r0 +array_length) (:r0 +array_begin)) '(:r2 :r3))
	(vp-sub-cr 1 :r2)
	(assign '(:r2) '((:r0 +array_length)))
	(vp-shl-cr (log2 +long_size) :r2)
	(vp-add-rr :r3 :r2)
	(vpif '(:r2 /= :r1))
		(assign '((:r2 0)) '(:r2))
		(assign '(:r2) '((:r1 0)))
	(endif)

	(exit :array :erase '(:r0 :r1))
	(vp-ret)

(def-func-end)

(def-method :array :erase2)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = element iterator (pptr)
	;outputs
	;:r0 = array object (ptr)
	;:r1 = element iterator (pptr)
	;trashes
	;:r2-:r3

	(entry :array :erase2 '(:r0 :r1))

	;swap last entry for erased entry
	(assign '((:r0 +array_length) (:r0 +array_begin)) '(:r2 :r3))
	(vp-sub-cr 2 :r2)
	(assign '(:r2) '((:r0 +array_length)))
	(vp-shl-cr (log2 +long_size) :r2)
	(vp-add-rr :r3 :r2)
	(vpif '(:r2 /= :r1))
		(assign '((:r2 0) (:r2 +long_size)) '(:r3 :r2))
		(assign '(:r3 :r2) '((:r1 0) (:r1 +long_size)))
	(endif)

	(exit :array :erase2 '(:r0 :r1))
	(vp-ret)

(def-func-end)

(def-method :array :eql)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = obj object (ptr)
	;outputs
	;:r0 = array object (ptr)
	;:r1 = 0 if same, else not
	;trashes
	;:r1-:r5

	(vp-rdef (this that len1 len2 itr1 itr2))

	(entry :array :eql `(,this ,that))

	(gotoif `(,this = ,that) 'same)
	(assign `((,this +obj_vtable) (,that +obj_vtable)) `(,len1 ,len2))
	(gotoif `(,len1 /= ,len2) 'not_same)
	(assign `((,this +array_length) (,that +array_length)) `(,len1 ,len2))
	(gotoif `(,len1 /= ,len2) 'not_same)
	(gotoif `(,len1 = 0) 'same)
	(assign `((,this +array_begin) (,that +array_begin)) `(,itr1 ,itr2))
	(vp-shl-cr (log2 +ptr_size) len1)
	(vp-add-rr itr1 len1)
	(loop-start)
		(vp-simd vp-cpy-ir `(,itr1 ,itr2) '(0 0) `(,that ,len2))
		(gotoif `(,that /= ,len2) 'not_same)
		(vp-simd vp-add-cr `(,+ptr_size) `(,itr1 ,itr2))
	(loop-until `(,itr1 = ,len1))

(vp-label 'same)
	(exit :array :eql `(,this 0))
	(vp-ret)

(vp-label 'not_same)
	(exit :array :eql `(,this -1))
	(vp-ret)

(def-func-end)

(def-method :array :cat)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = list of array objects (ptr)
	;outputs
	;:r0 = new array object (ptr)
	;trashes
	;:r0-:r9

	(vp-rdef (this seqs_begin di src si ei
		len total seqs seqs_end))

	(entry :array :cat `(,this ,seqs))

	(call :array :vcreate `(,this) `(,this))
	(class/array/get_both seqs seqs_begin seqs_end)
	(vpif `(,seqs_begin /= ,seqs_end))
		;first set the capacity/length
		(vp-xor-rr total total)
		(loop-start)
			(assign `((,seqs_begin 0)) `(,src))
			(vp-add-cr +ptr_size seqs_begin)
			(assign `((,src +array_length)) `(,len))
			(vp-add-rr len total)
		(loop-until `(,seqs_begin = ,seqs_end))
		(assign `(,total) `((,this +array_length)))
		(call :array :set_cap `(,this ,total) `(,this))
		;now transfer the sequences
		(assign `((,this +array_begin) (,seqs +array_begin)) `(,di ,seqs_begin))
		(loop-start)
			(assign `((,seqs_begin 0)) `(,src))
			(vp-add-cr +ptr_size seqs_begin)
			(class/array/get_both src si ei)
			(vpif `(,si /= ,ei))
				;copy the sequence
				(loop-start)
					(vp-cpy-ir si 0 len)
					(vp-simd vp-add-cr `(,+long_size) `(,si ,di))
					(vp-cpy-ri len di (neg +long_size))
				(loop-until `(,si = ,ei))
			(endif)
		(loop-until `(,seqs_begin = ,seqs_end))
	(endif)

	(exit :array :cat `(,this))
	(vp-ret)

(def-func-end)

(def-method :array :slice)
	;inputs
	;:r0 = array object (ptr)
	;:r1 = element start index (uint)
	;:r2 = element end index (uint)
	;outputs
	;:r0 = slice array object (ptr)
	;trashes
	;:r0-:r8

	(vp-rdef (src si ei this di total) '(:r6 :r7 :r8))

	(entry :array :slice `(,src ,si ,ei))

	(call :array :vcreate `(,src) `(,this))
	(vpif `(,si /= ,ei))
		;first set the capacity/length
		(vp-cpy-rr si total)
		(vp-sub-rr ei total)
		(vp-abs-rr total total)
		(assign `(,total) `((,this +array_length)))
		(call :array :set_cap `(,this ,total) `(,this))
		;now transfer the slice, reversed if needed
		(class/array/get_iters src si ei)
		(assign `((,this +array_begin)) `(,di))
		(vpif `(,si < ,ei))
			(loop-start)
				(vp-cpy-ir si 0 total)
				(vp-simd vp-add-cr `(,+long_size) `(,si ,di))
				(vp-cpy-ri total di (neg +long_size))
			(loop-until `(,si = ,ei))
		(else)
			(loop-start)
				(vp-cpy-ir si (neg +long_size) total)
				(vp-simd vp-add-cr `(,(neg +long_size) ,+long_size) `(,si ,di))
				(vp-cpy-ri total di (neg +long_size))
			(loop-until `(,si = ,ei))
		(endif)
	(endif)

	(exit :array :slice `(,this))
	(vp-ret)

(def-func-end)

(def-method :array :splice)
	;inputs
	;:r0 = src1 array object (ptr)
	;:r1 = src2 array object (ptr)
	;:r2 = nums object (ptr)
	;outputs
	;:r0 = new array object (ptr)
	;trashes
	;:r0-:r11

	(vp-rdef (this idx_begin di si ei swp_xor len total
		src1 src2 idxs idx_end))

	(entry :array :splice `(,src1 ,src2 ,idxs))

	(call :array :vcreate `(,src1) `(,this))
	(class/array/get_both idxs idx_begin idx_end)
	(vpif `(,idx_begin /= ,idx_end))
		;first set the capacity/length
		(assign `((,src1 +array_length) (,src2 +array_length)) `(,len ,ei))
		(vp-cpy-rr len swp_xor)
		(vp-xor-rr ei swp_xor)
		(vp-xor-rr total total)
		(loop-start)
			;indices
			(vp-simd vp-cpy-ir `(,idx_begin) `(0 ,+long_size) `(,si ,ei))
			(vp-add-cr (* +long_size 2) idx_begin)
			;the length this time
			(seq-elem-index si len)
			(seq-elem-index ei len)
			(vp-xor-rr swp_xor len)
			;sum the absolute val of index diff
			(vp-sub-rr si ei)
			(vp-abs-rr ei ei)
			(vp-add-rr ei total)
		(loop-until `(,idx_begin = ,idx_end))
		(assign `(,total) `((,this +array_length)))
		(call :array :set_cap `(,this ,total) `(,this))
		;now transfer the slices
		(assign `((,this +array_begin) (,idxs +array_begin)) `(,di ,idx_begin))
		(vp-cpy-rr src1 swp_xor)
		(vp-xor-rr src2 swp_xor)
		(loop-start)
			;indices
			(vp-simd vp-cpy-ir `(,idx_begin) `(0 ,+long_size) `(,si ,ei))
			(vp-add-cr (* +long_size 2) idx_begin)
			;the source this time
			(assign `((,src1 +array_begin) (,src1 +array_length)) `(,src2 ,len))
			(seq-elem-index si len)
			(seq-elem-index ei len)
			(vp-xor-rr swp_xor src1)
			(vpif `(,si /= ,ei))
				(vp-simd vp-shl-cr `(,(log2 +long_size)) `(,si ,ei))
				(vp-simd vp-add-rr `(,src2) `(,si ,ei))
				;copy the slice, reverse if required
				(vpif `(,si < ,ei))
					(loop-start)
						(vp-cpy-ir si 0 len)
						(vp-simd vp-add-cr `(,+long_size) `(,si ,di))
						(vp-cpy-ri len di (neg +long_size))
					(loop-until `(,si = ,ei))
				(else)
					(loop-start)
						(vp-cpy-ir si (neg +long_size) len)
						(vp-simd vp-add-cr `(,(neg +long_size) ,+long_size) `(,si ,di))
						(vp-cpy-ri len di (neg +long_size))
					(loop-until `(,si = ,ei))
				(endif)
			(endif)
		(loop-until `(,idx_begin = ,idx_end))
	(endif)

	(exit :array :splice `(,this))
	(vp-ret)

(def-func-end)
