(include "lib/asm/func.inc")
(include "lib/consts/chars.inc")
(include "./class.inc")
(include "././sym/class.inc")
(include "././stream/class.inc")

(gen-create :list)
(gen-vtable :list)
(gen-type :list)

(def-method :list :deinit)
	;inputs
	;:r0 = list object (ptr)
	;outputs
	;:r0 = list object (ptr)
	;trashes
	;:r1-:r14

	(entry :list :deinit '(:r0))

	(d-call :list :clear '(:r0) '(:r0))
	(s-jump :list :deinit '(:r0))

(def-func-end)

(def-method :list :clear)
	;inputs
	;:r0 = list object (ptr)
	;outputs
	;:r0 = list object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(ptr this)
		(pptr iter_begin iter_end))

	(vp-rdef (this iter_begin iter_end))

	(entry :list :clear `(,this))

	;deref all elements
	(class/array/get_both this iter_begin iter_end)
	(vpif `(,iter_begin /= ,iter_end))
		(push-scope)
		(assign `(,this ,iter_end) {this, iter_end})
		(loop-start)
			;must preserve what we care about as :deref can trash all !
			(assign `(,iter_begin) {iter_begin})
			(call :obj :deref `((,iter_begin 0)))
			(assign {iter_begin, iter_end} `(,iter_begin ,iter_end))
			(vp-add-cr +ptr_size iter_begin)
		(loop-until `(,iter_begin = ,iter_end))
		(assign {this} `(,this))
		(pop-scope)
		;only need to do this if we actually had a none empty list !
		(s-call :list :clear `(,this) `(,this))
	(endif)

	(exit :list :clear `(,this))
	(vp-ret)

(def-func-end)

(def-method :list :ref_elem)
	;inputs
	;:r0 = list object (ptr)
	;:r1 = element index (uint)
	;outputs
	;:r0 = list object (ptr)
	;:r1 = element object (ptr)
	;trashes
	;:r1-:r2

	(entry :list :ref_elem '(:r0 :r1))

	(class/array/get_elem :r0 :r1 :r1 :r2)
	(class/obj/ref :r1 :r2)

	(exit :list :ref_elem '(:r0 :r1))
	(vp-ret)

(def-func-end)

(def-method :list :ref_back)
	;inputs
	;:r0 = list object (ptr)
	;outputs
	;:r0 = list object (ptr)
	;:r1 = element object (ptr)
	;trashes
	;:r1-:r2

	(entry :list :ref_back '(:r0))

	(call :list :pop_back '(:r0) '(:r0 :r1))

	(exit :list :ref_back '(:r0 :r1))
	(vp-ret)

(def-func-end)

(def-method :list :set_elem)
	;inputs
	;:r0 = list object (ptr)
	;:r1 = element object (ptr)
	;:r2 = element index (uint)
	;outputs
	;:r0 = list object (ptr)
	;trashes
	;:r1-:r14

	(entry :list :set_elem '(:r0 :r1 :r2))

	(assign '((:r0 array_begin)) '(:r3))
	(vp-shl-cr (log2 +ptr_size) :r2)
	(vp-push :r0)
	(assign '((:r2 :r3) :r1) '(:r0 (:r2 :r3)))
	(call :obj :deref '(:r0))
	(vp-pop :r0)

	(exit :list :set_elem '(:r0))
	(vp-ret)

(def-func-end)

(def-method :list :append)
	;inputs
	;:r0 = list object (ptr)
	;:r1 = source list object (ptr)
	;:r2 = element start index (uint)
	;:r3 = element end index (uint)
	;outputs
	;:r0 = list object (ptr)
	;trashes
	;:r1-:r9

	(entry :list :append '(:r0 :r1 :r2 :r3))

	(vpif '(:r2 /= :r3))
		;save inputs
		(assign '(:r1 :r2 :r3) '(:r6 :r7 :r8))

		;extend list
		(assign '((:r0 array_length)) '(:r9))
		(vp-sub-rr :r2 :r3)
		(assign '((& :r3 :r9)) '(:r1))
		(assign '(:r1) '((:r0 array_length)))
		(call :list :set_cap '(:r0 :r1) '(:r0))

		;append and ref elements
		(class/array/get_iters :r6 :r7 :r8 :r1)
		(class/array/get_iter :r0 :r9 :r1)
		(loop-start)
			(assign '((:r7 0)) '(:r1))
			(vp-simd vp-add-cr `(,+ptr_size) '(:r9 :r7))
			(assign '(:r1) `((:r9 ,(neg +ptr_size))))
			(class/obj/ref :r1 :r2)
		(loop-until '(:r7 = :r8))
	(endif)

	(exit :list :append '(:r0))
	(vp-ret)

(def-func-end)

(def-method :list :find)
	;inputs
	;:r0 = list object (ptr)
	;:r1 = element object (ptr)
	;:r2 = start index (uint)
	;outputs
	;:r0 = list object (ptr)
	;:r1 = element object (ptr)
	;:r2 = -1, else index (int)
	;trashes
	;:r2-:r9

	(vp-rdef (this iter_begin iter_end elm)
		'(:r7 :r8 :r9))

	(entry :list :find '(:r0 :r1 :r2))

	;what type of element search ?
	(f-bind :sym :vtable iter_begin)
	(assign '((:r1 obj_vtable)) `(,iter_end))
	(vpif `(,iter_begin = ,iter_end))
		;symbol
		(s-jump :list :find '(:r0 :r1 :r2))
	(endif)
	(assign '(:r0 :r1) `(,this ,elm))
	(class/array/get_both this iter_begin iter_end)
	(gotoif `(,iter_begin = ,iter_end) 'notfound)
	(vp-shl-cr (log2 +long_size) :r2)
	(vp-add-rr :r2 iter_begin)
	(loop-start)
		(call :obj :eql `(,elm (,iter_begin 0)) `(,elm tmp))
		(gotoif `(,tmp = 0) 'found)
		(vp-add-cr +ptr_size iter_begin)
	(loop-until `(,iter_begin = ,iter_end))

(vp-label 'notfound)
	(exit :list :find `(,this ,elm -1))
	(vp-ret)

(vp-label 'found)
	(assign `((,this array_begin)) `(,iter_end))
	(vp-sub-rr iter_end iter_begin)
	(vp-shr-cr (log2 +ptr_size) iter_begin)

	(exit :list :find `(,this ,elm ,iter_begin))
	(vp-ret)

(def-func-end)

(def-method :list :rfind)
	;inputs
	;:r0 = list object (ptr)
	;:r1 = element object (ptr)
	;:r2 = start index (uint)
	;outputs
	;:r0 = list object (ptr)
	;:r1 = element object (ptr)
	;:r2 = 0, else index (int)
	;trashes
	;:r2-:r9

	(vp-rdef (this iter_begin iter_end elm)
		'(:r7 :r8 :r9))

	(entry :list :rfind '(:r0 :r1 :r2))

	(gotoif '(:r2 = 0) 'exit)
	;what type of element search ?
	(f-bind :sym :vtable iter_begin)
	(assign '((:r1 obj_vtable)) `(,iter_end))
	(vpif `(,iter_begin = ,iter_end))
		;symbol
		(s-jump :list :rfind '(:r0 :r1 :r2))
	(endif)
	(assign '(:r0 :r1) `(,this ,elm))
	(assign `((,this array_begin)) `(,iter_end))
	(vp-shl-cr (log2 +long_size) :r2)
	(vp-lea-d iter_end :r2 iter_begin)
	(loop-start)
		(call :obj :eql `(,elm (,iter_begin ,(neg +ptr_size))) `(,elm tmp))
		(breakif `(,tmp = 0))
		(vp-sub-cr +ptr_size iter_begin)
	(loop-until `(,iter_begin = ,iter_end))

(vp-label 'notfound)
	(vp-sub-rr iter_end iter_begin)
	(vp-asr-cr (log2 +ptr_size) iter_begin)
	(exit :list :rfind `(,this ,elm ,iter_begin))
(vp-label 'exit)
	(vp-ret)

(def-func-end)

(def-method :list :erase)
	;inputs
	;:r0 = list object (ptr)
	;:r1 = element iterator (pptr)
	;outputs
	;:r0 = list object (ptr)
	;:r1 = element iterator (pptr)
	;trashes
	;:r2-:r14

	(entry :list :erase '(:r0 :r1))

	(vp-push :r0 :r1)
	(call :obj :deref '((:r1 0)))
	(vp-pop :r0 :r1)
	(s-jump :list :erase '(:r0 :r1))

(def-func-end)

(def-method :list :erase2)
	;inputs
	;:r0 = list object (ptr)
	;:r1 = element iterator (pptr)
	;outputs
	;:r0 = list object (ptr)
	;:r1 = element iterator (pptr)
	;trashes
	;:r2-:r14

	(entry :list :erase2 '(:r0 :r1))

	(vp-push :r0 :r1)
	(call :obj :deref '((:r1 0)))
	(assign '((:rsp 0)) '(:r1))
	(call :obj :deref '((:r1 +ptr_size)))
	(vp-pop :r0 :r1)
	(s-jump :list :erase2 '(:r0 :r1))

(def-func-end)

(def-method :list :copy)
	;inputs
	;:r0 = list object (ptr)
	;outputs
	;:r0 = list object (ptr)
	;:r1 = copy list object (ptr)
	;trashes
	;:r1-:r14

	(entry :list :copy '(:r0))

	;ref and then copy it
	(vp-push :r0 :r0)
	(class/obj/ref :r0 :r1)

	(call :array :create :nil '(:r10))
	(f-bind :list :vtable :r12)
	(assign '((& :rsp 0)) '(:r9))
	(loop-start)
		;replace form with copy, deref can't cause destroy !
		(vp-cpy-ir :r9 0 :r0)
		(d-call :list :slice '(:r0 0 (:r0 array_length)) '(:r1))
		(vp-cpy-ir :r9 0 :r0)
		(class/obj/ref :r0 :r2 -1)
		(vp-cpy-ri :r1 :r9 0)

		;push this lists branches
		(class/array/get_both :r1 :r1 :r6)
		(assign '(:r10) '(:r0))
		(loop-while '(:r1 /= :r6))
			(vp-cpy-ir :r1 0 :r2)
			(assign '((:r2 obj_vtable)) '(:r2))
			(vpif '(:r2 = :r12))
				(call :array :push_back '(:r0 :r1) '(:r0 :r1 _ _))
			(endif)
			(vp-add-cr +ptr_size :r1)
		(loop-end)

		;pop back stack
		(assign '((:r0 array_length)) '(:r1))
		(breakif '(:r1 = 0))
		(vp-sub-cr 1 :r1)
		(assign '(:r1) '((:r0 array_length)))
		(class/array/get_elem :r0 :r1 :r9 :r2)
	(loop-end)
	(call :array :deref '(:r10))
	(vp-pop :r0 :r1)

	(exit :list :copy '(:r0 :r1))
	(vp-ret)

(def-func-end)

(def-method :list :print)
	;inputs
	;:r0 = list object (ptr)
	;:r1 = stream object (ptr)
	;outputs
	;:r0 = list object (ptr)
	;trashes
	;:r1-:r14

	(def-struct local 0
		(ptr this stream)
		(plong iter_begin iter_end))

	(vp-alloc local_size)
	(entry :list :print '(:r0 :r1))
	(assign '(:r0 :r1) '((:rsp local_this) (:rsp local_stream)))

	(call :stream :write_char '(:r1 +char_lrb))
	(call :list :get_both '((:rsp local_this)) '(_ :r1 :r2))
	(vpif '(:r1 /= :r2))
		(assign '(:r1 :r2) '((:rsp local_iter_begin) (:rsp local_iter_end)))
		(loop-start)
			(call :obj :print '((:r1 0) (:rsp local_stream)))
			(assign '((:rsp local_iter_begin) (:rsp local_iter_end)) '(:r1 :r2))
			(vp-add-cr +long_size :r1)
			(breakif '(:r1 = :r2))
			(assign '(:r1) '((:rsp local_iter_begin)))
			(call :stream :write_char '((:rsp local_stream) +char_space))
			(assign '((:rsp local_iter_begin)) '(:r1))
		(loop-end)
	(endif)
	(call :stream :write_char '((:rsp local_stream) +char_rrb))

	(exit :list :print '((:rsp local_this)))
	(vp-free local_size)
	(vp-ret)

(def-func-end)

(def-method :list :min_length)
	;inputs
	;:r0 = list of seq objects (ptr)
	;outputs
	;:r0 = list of seq objects (ptr)
	;:r1 = +max_int, or minimum length (uint)
	;trashes
	;:r1-:r5

	(vp-rdef (this min_len iter_begin iter_end) '(:r2 :r3 :r4 :r5))

	(entry :list :min_length `(,this))

	(vp-cpy-cr +max_int min_len)
	(class/array/get_both this iter_begin iter_end)
	(vpif `(,iter_begin /= ,iter_end))
		(loop-start)
			(call :seq :get_length `((,iter_begin 0)) '(_ len))
			(vp-add-cr +ptr_size iter_begin)
			(vp-min-rr len min_len)
		(loop-until `(,iter_begin = ,iter_end))
	(endif)

	(exit :list :min_length `(,this ,min_len))
	(vp-ret)

(def-func-end)

(def-method :list :collect)
	;inputs
	;:r0 = list object (ptr)
	;:r1 = list of seq objects (ptr)
	;:r2 = element index (uint)
	;outputs
	;:r0 = list object (ptr)
	;trashes
	;:r1-:r11

	(vp-rdef (this iter_begin iter_end index) '(:r8 :r9 :r10 :r11))

	(entry :list :collect `(,this :r1 ,index))

	(class/array/get_both :r1 iter_begin iter_end)
	(vpif `(,iter_begin /= ,iter_end))
		(loop-start)
			(call :seq :ref_elem `((,iter_begin 0) ,index) '(_ elm))
			(call :list :push_back `(,this ,elm))
			(vp-add-cr +ptr_size iter_begin)
		(loop-until `(,iter_begin = ,iter_end))
	(endif)

	(exit :list :collect `(,this))
	(vp-ret)

(def-func-end)

(def-method :list :ref_all)
	;inputs
	;:r0 = list object (ptr)
	;outputs
	;:r0 = list object (ptr)
	;trashes
	;:r1-:r4

	(vp-rdef (this iter_begin iter_end elm tmp))

	(entry :list :ref_all `(,this))

	;ref the elements
	(class/array/get_both this iter_begin iter_end)
	(vpif `(,iter_begin /= ,iter_end))
		(loop-start)
			(vp-cpy-ir iter_begin 0 elm)
			(vp-add-cr +ptr_size iter_begin)
			(class/obj/ref elm tmp)
		(loop-until `(,iter_begin = ,iter_end))
	(endif)

	(exit :list :ref_all `(,this))
	(vp-ret)

(def-func-end)

(def-method :list :cat)
	;inputs
	;:r0 = list object (ptr)
	;:r1 = list of list objects (ptr)
	;outputs
	;:r0 = new list object (ptr)
	;trashes
	;:r0-:r9

	(entry :list :cat '(:r0 :r1))

	(class/list/cat)

	(exit :list :cat '(:r0))
	(vp-ret)

(def-func-end)

(def-method :list :slice)
	;inputs
	;:r0 = list object (ptr)
	;:r1 = element start index (uint)
	;:r2 = element end index (uint)
	;outputs
	;:r0 = slice list object (ptr)
	;trashes
	;:r0-:r8

	(entry :list :slice '(:r0 :r1 :r2))

	(class/list/slice)

	(exit :list :slice '(:r0))
	(vp-ret)

(def-func-end)

(def-method :list :splice)
	;inputs
	;:r0 = src1 list object (ptr)
	;:r1 = src2 list object (ptr)
	;:r2 = nums object (ptr)
	;outputs
	;:r0 = splice list object (ptr)
	;trashes
	;:r0-:r11

	(entry :list :splice '(:r0 :r1 :r2))

	(class/list/splice)

	(exit :list :splice '(:r0))
	(vp-ret)

(def-func-end)
