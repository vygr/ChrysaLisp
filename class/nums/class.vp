(include "lib/asm/func.inc")
(include "./class.inc")
(include "././sym/class.inc")
(include "././list/class.inc")

(gen-create 'nums)
(gen-vtable 'nums)
(gen-type 'nums)

(def-method 'nums :add)
	;inputs
	;:r0 = nums object (ptr)
	;:r1 = source1 nums object, can be same (ptr)
	;:r2 = source2 nums object, can be same (ptr)
	;outputs
	;:r0 = nums object (ptr)
	;:r1 = 0 if error, else ok
	;trashes
	;:r1-:r6

	(vp-rdef (dst src1 src2 dst1 src_end e0 e1))

	(entry 'nums :add `(,dst ,src1 ,src2))

	(assign `((,src1 array_length)) `(,src_end))
	(vp-simd vp-cpy-ir `(,src1 ,src2 ,dst) `(,array_begin) `(,src1 ,src2 ,dst1))
	(vp-shl-cr (log2 +ptr_size) src_end)
	(vp-add-rr src1 src_end)
	(vec-loop-until `(,src1 ,src2) `(,e0 ,e1) src_end dst1
		(# (vp-add-rr %1 %0) %0))

	(exit 'nums :add `(,dst -1))
	(vp-ret)

(def-func-end)

(def-method 'nums :sub)
	;inputs
	;:r0 = nums object (ptr)
	;:r1 = source1 nums object, can be same (ptr)
	;:r2 = source2 nums object, can be same (ptr)
	;outputs
	;:r0 = nums object (ptr)
	;:r1 = 0 if error, else ok
	;trashes
	;:r1-:r6

	(vp-rdef (dst src1 src2 dst1 src_end e0 e1))

	(entry 'nums :sub `(,dst ,src1 ,src2))

	(assign `((,src1 array_length)) `(,src_end))
	(vp-simd vp-cpy-ir `(,src1 ,src2 ,dst) `(,array_begin) `(,src1 ,src2 ,dst1))
	(vp-shl-cr (log2 +ptr_size) src_end)
	(vp-add-rr src1 src_end)
	(vec-loop-until `(,src1 ,src2) `(,e0 ,e1) src_end dst1
		(# (vp-sub-rr %1 %0) %0))

	(exit 'nums :sub `(,dst -1))
	(vp-ret)

(def-func-end)

(def-method 'nums :min)
	;inputs
	;:r0 = nums object (ptr)
	;:r1 = source1 nums object, can be same (ptr)
	;:r2 = source2 nums object, can be same (ptr)
	;outputs
	;:r0 = nums object (ptr)
	;:r1 = 0 if error, else ok
	;trashes
	;:r1-:r6

	(vp-rdef (dst src1 src2 dst1 src_end e0 e1))

	(entry 'nums :min `(,dst ,src1 ,src2))

	(assign `((,src1 array_length)) `(,src_end))
	(vp-simd vp-cpy-ir `(,src1 ,src2 ,dst) `(,array_begin) `(,src1 ,src2 ,dst1))
	(vp-shl-cr (log2 +ptr_size) src_end)
	(vp-add-rr src1 src_end)
	(vec-loop-until `(,src1 ,src2) `(,e0 ,e1) src_end dst1
		(# (vp-min-rr %1 %0) %0))

	(exit 'nums :min `(,dst -1))
	(vp-ret)

(def-func-end)

(def-method 'nums :max)
	;inputs
	;:r0 = nums object (ptr)
	;:r1 = source1 nums object, can be same (ptr)
	;:r2 = source2 nums object, can be same (ptr)
	;outputs
	;:r0 = nums object (ptr)
	;:r1 = 0 if error, else ok
	;trashes
	;:r1-:r6

	(vp-rdef (dst src1 src2 dst1 src_end e0 e1))

	(entry 'nums :max `(,dst ,src1 ,src2))

	(assign `((,src1 array_length)) `(,src_end))
	(vp-simd vp-cpy-ir `(,src1 ,src2 ,dst) `(,array_begin) `(,src1 ,src2 ,dst1))
	(vp-shl-cr (log2 +ptr_size) src_end)
	(vp-add-rr src1 src_end)
	(vec-loop-until `(,src1 ,src2) `(,e0 ,e1) src_end dst1
		(# (vp-max-rr %1 %0) %0))

	(exit 'nums :max `(,dst -1))
	(vp-ret)

(def-func-end)

(def-method 'nums :mul)
	;inputs
	;:r0 = nums object (ptr)
	;:r1 = source1 nums object, can be same (ptr)
	;:r2 = source2 nums object, can be same (ptr)
	;outputs
	;:r0 = nums object (ptr)
	;:r1 = 0 if error, else ok
	;trashes
	;:r1-:r6

	(vp-rdef (dst src1 src2 dst1 src_end e0 e1))

	(entry 'nums :mul `(,dst ,src1 ,src2))

	(assign `((,src1 array_length)) `(,src_end))
	(vp-simd vp-cpy-ir `(,src1 ,src2 ,dst) `(,array_begin) `(,src1 ,src2 ,dst1))
	(vp-shl-cr (log2 +ptr_size) src_end)
	(vp-add-rr src1 src_end)
	(vec-loop-until `(,src1 ,src2) `(,e0 ,e1) src_end dst1
		(# (vp-mul-rr %1 %0) %0))

	(exit 'nums :mul `(,dst -1))
	(vp-ret)

(def-func-end)

(def-method 'nums :div)
	;inputs
	;:r0 = nums object (ptr)
	;:r1 = source1 nums object, can be same (ptr)
	;:r2 = source2 nums object, can be same (ptr)
	;outputs
	;:r0 = nums object (ptr)
	;:r1 = 0 if error, else ok
	;trashes
	;:r1-:r7

	(vp-rdef (e0 e1 high src1 src2 dst1 src_end dst))

	(entry 'nums :div `(,dst ,e1 ,high))

	(assign `((,e1 array_length)) `(,src_end))
	(vp-simd vp-cpy-ir `(,e1 ,high ,dst) `(,array_begin) `(,src1 ,src2 ,dst1))
	(vp-shl-cr (log2 +ptr_size) src_end)
	(vp-add-rr src1 src_end)
	(vec-loop-until `(,src1 ,src2) `(,e0 ,e1) src_end dst1
		(#  (errorif `(,%%1 = 0) 'error)
			(vp-ext-rr %0 high)
			(vp-div-rrr %1 high %0)
			%0))

	(exit 'nums :div `(,dst -1))
	(vp-ret)
(vp-label 'error)
	(exit 'nums :div `(,dst 0))
	(vp-ret)

(def-func-end)

(def-method 'nums :mod)
	;inputs
	;:r0 = nums object (ptr)
	;:r1 = source1 nums object, can be same (ptr)
	;:r2 = source2 nums object, can be same (ptr)
	;outputs
	;:r0 = nums object (ptr)
	;:r1 = 0 if error, else ok
	;trashes
	;:r1-:r7

	(vp-rdef (e0 e1 high src1 src2 dst1 src_end dst))

	(entry 'nums :mod `(,dst ,e1 ,high))

	(assign `((,e1 array_length)) `(,src_end))
	(vp-simd vp-cpy-ir `(,e1 ,high ,dst) `(,array_begin) `(,src1 ,src2 ,dst1))
	(vp-shl-cr (log2 +ptr_size) src_end)
	(vp-add-rr src1 src_end)
	(vec-loop-until `(,src1 ,src2) `(,e0 ,e1) src_end dst1
		(# (errorif `(,%%1 = 0) 'error)
			(vp-ext-rr %0 high)
			(vp-div-rrr %1 high %0)
			high))

	(exit 'nums :mod `(,dst -1))
	(vp-ret)
(vp-label 'error)
	(exit 'nums :mod `(,dst 0))
	(vp-ret)

(def-func-end)

(def-method 'nums :abs)
	;inputs
	;:r0 = nums object (ptr)
	;:r1 = source nums object, can be same (ptr)
	;outputs
	;:r0 = nums object (ptr)
	;trashes
	;:r1-:r4

	(vp-rdef (dst src1 dst1 src_end e0))

	(entry 'nums :abs `(,dst ,src1))

	(assign `((,src1 array_length)) `(,src_end))
	(vp-simd vp-cpy-ir `(,src1 ,dst) `(,array_begin) `(,src1 ,dst1))
	(vp-shl-cr (log2 +ptr_size) src_end)
	(vp-add-rr src1 src_end)
	(vec-loop-until `(,src1) `(,e0) src_end dst1
		(# (vp-abs-rr %0 %0) %0))

	(exit 'nums :abs `(,dst))
	(vp-ret)

(def-func-end)

(def-method 'nums :sum)
	;inputs
	;:r0 = nums object (ptr)
	;outputs
	;:r0 = nums object (ptr)
	;:r1 = sum (long)
	;trashes
	;:r1-:r4

	(vp-rdef (dst sum dst1 dst_end e0))

	(entry 'nums :sum `(,dst))

	(assign `((,dst array_length)) `(,dst_end))
	(assign (map (# (list %0 array_begin)) `(,dst)) `(,dst1))
	(vp-xor-rr sum sum)
	(vp-shl-cr (log2 +ptr_size) dst_end)
	(vp-add-rr dst1 dst_end)
	(vec-loop-until `(,dst1) `(,e0) dst_end :nil
		(# (vp-add-rr %0 sum)))

	(exit 'nums :sum `(,dst ,sum))
	(vp-ret)

(def-func-end)

(def-method 'nums :scale)
	;inputs
	;:r0 = nums object (ptr)
	;:r1 = source nums object, can be same (ptr)
	;:r2 = scale (int)
	;outputs
	;:r0 = nums object (ptr)
	;trashes
	;:r1-:r5

	(vp-rdef (dst src1 scale dst1 src_end e0))

	(entry 'nums :scale `(,dst ,src1 ,scale))

	(assign `((,src1 array_length)) `(,src_end))
	(vp-simd vp-cpy-ir `(,src1 ,dst) `(,array_begin) `(,src1 ,dst1))
	(vp-shl-cr (log2 +ptr_size) src_end)
	(vp-add-rr src1 src_end)
	(vec-loop-until `(,src1) `(,e0) src_end dst1
		(# (vp-mul-rr scale %0) %0))

	(exit 'nums :scale `(,dst))
	(vp-ret)

(def-func-end)

(def-method 'nums :dot)
	;inputs
	;:r0 = nums object (ptr)
	;:r1 = nums object, can be same (ptr)
	;outputs
	;:r0 = nums object (ptr)
	;:r1 = dot product (long)
	;trashes
	;:r1-:r6

	(vp-rdef (src dot src1 src2 src_end e0 e1))

	(entry 'nums :dot `(,src1 ,dot))

	(assign `((,src1 array_length)) `(,src_end))
	(assign (map (# (list %0 array_begin)) `(,dot ,src)) `(,src1 ,src2))
	(vp-xor-rr dot dot)
	(vp-shl-cr (log2 +ptr_size) src_end)
	(vp-add-rr src1 src_end)
	(vec-loop-until `(,src1 ,src2) `(,e0 ,e1) src_end :nil
		(# (vp-mul-rr %0 %1) (vp-add-rr %1 dot)))

	(exit 'nums :dot `(,src ,dot))
	(vp-ret)

(def-func-end)

(def-method 'nums :hash)
	;inputs
	;:r0 = nums object (ptr)
	;outputs
	;:r0 = nums object (ptr)
	;:r1 = hash code (long)
	;trashes
	;:r1-:r4

	(vp-rdef (src val src1 src_end e0))

	(entry 'nums :hash `(,src))

	(assign `((,src array_length)) `(,src_end))
	(assign (map (# (list %0 array_begin)) `(,src)) `(,src1))
	(vp-xor-rr val val)
	(vp-shl-cr (log2 +ptr_size) src_end)
	(vp-add-rr src1 src_end)
	(vec-loop-while `(,src1) `(,e0) src_end :nil
		(# (vp-xor-rr %0 val)))
	(vp-abs-rr val val)

	(exit 'nums :hash `(,src ,val))
	(vp-ret)

(def-func-end)
