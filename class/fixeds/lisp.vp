(include "lib/asm/func.inc")
(include "./class.inc")
(include "././lisp/class.inc")

(def-method :fixeds :lisp_frac)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry :fixeds :lisp_frac '(:r0 :r1))

	(vp-push :r1)
	(array-bind-args :r1 '(:r2))
	(v-bind :fixeds :frac :r2 :r2)
	(call :nums :lisp_vecop2 '(:r0 :r1 :r2) '(:r0 :r1))
	(vp-pop :r3)
	(errorif '(:r1 = 0) 'error)

	(exit :fixeds :lisp_frac '(:r0 :r1))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error '(:r0 "(fixeds-frac fixeds [fixeds])" +error_msg_wrong_types :r3)))

(def-func-end)

(def-method :fixeds :lisp_floor)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry :fixeds :lisp_floor '(:r0 :r1))

	(vp-push :r1)
	(array-bind-args :r1 '(:r2))
	(v-bind :fixeds :floor :r2 :r2)
	(call :nums :lisp_vecop2 '(:r0 :r1 :r2) '(:r0 :r1))
	(vp-pop :r3)
	(errorif '(:r1 = 0) 'error)

	(exit :fixeds :lisp_floor '(:r0 :r1))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error '(:r0 "(fixeds-floor fixeds [fixeds])" +error_msg_wrong_types :r3)))

(def-func-end)

(def-method :fixeds :lisp_ceil)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry :fixeds :lisp_ceil '(:r0 :r1))

	(vp-push :r1)
	(array-bind-args :r1 '(:r2))
	(v-bind :fixeds :ceil :r2 :r2)
	(call :nums :lisp_vecop2 '(:r0 :r1 :r2) '(:r0 :r1))
	(vp-pop :r3)
	(errorif '(:r1 = 0) 'error)

	(exit :fixeds :lisp_ceil '(:r0 :r1))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error '(:r0 "(fixeds-ceil fixeds [fixeds])" +error_msg_wrong_types :r3)))

(def-func-end)

(def-method :fixeds :lisp_mat4x4_mul)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(vp-rdef (dst iter_begin nums1 nums2 this args argc len1 len2)
		'(:r0 :r6 :r7 :r8 :r9 :r1 :r11 :r12 :r13))

	(entry :fixeds :lisp_mat4x4_mul `(,this ,args))

	(errorif-lisp-args-sig 'error :r1 2 3)

	(assign `((,args +array_length)) `(,argc))
	(assign `((,args +array_begin)) `(,iter_begin))

	(array-get-args iter_begin `(,nums1 ,nums2))

	(assign `((,nums1 +array_length)) `(,len1))
	(errorif `(,len1 /= 16) 'error)
	(assign `((,nums2 +array_length)) `(,len2))
	(errorif `(,len2 /= 16) 'error)

	(vpif `(,argc = 2))
		(v-call :nums :vcreate `(,dst) `(,dst) nums1 iter_begin)
		(call :nums :set_cap `(,dst 16) `(,dst))
		(call :nums :set_length `(,dst 16) `(,dst _))
	(else)
		(vp-cpy-ir iter_begin (* +ptr_size 2) dst)
		(vpif `(,dst = +lisp_sym_nil))
			(v-call :nums :vcreate `(,dst) `(,dst) nums1 iter_begin)
			(call :nums :set_cap `(,dst 16) `(,dst))
			(call :nums :set_length `(,dst 16) `(,dst _))
		(else)
			(assign `((,dst +array_length)) `(,len1))
			(errorif `(,len1 < 16) 'error)
			(call :obj :ref `(,dst) `(,dst))
		(endif)
	(endif)
	(v-call :fixeds :mat4x4_mul `(,dst ,nums1 ,nums2) `(,dst) dst iter_begin)

	(exit :fixeds :lisp_mat4x4_mul `(,this ,dst))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error `(,this "(mat4x4-mul ma mb [out])" +error_msg_wrong_types ,args))
	(signature '(:fixeds :fixeds :fixeds)))

(def-func-end)

(def-method :fixeds :lisp_mat4x4_v4_mul)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(vp-rdef (dst iter_begin nums1 nums2 this args argc len1 len2)
		'(:r0 :r6 :r7 :r8 :r9 :r1 :r11 :r12 :r13))

	(entry :fixeds :lisp_mat4x4_v4_mul `(,this ,args))

	(errorif-lisp-args-sig 'error :r1 2 3)

	(assign `((,args +array_length)) `(,argc))
	(assign `((,args +array_begin)) `(,iter_begin))

	(array-get-args iter_begin `(,nums1 ,nums2))

	(assign `((,nums1 +array_length)) `(,len1))
	(errorif `(,len1 /= 16) 'error)
	(assign `((,nums2 +array_length)) `(,len2))
	(errorif `(,len2 /= 4) 'error)

	(vpif `(,argc = 2))
		(v-call :nums :vcreate `(,dst) `(,dst) nums2 iter_begin) ; using nums2 as template
		(call :nums :set_cap `(,dst 4) `(,dst))
		(call :nums :set_length `(,dst 4) `(,dst _))
	(else)
		(vp-cpy-ir iter_begin (* +ptr_size 2) dst)
		(vpif `(,dst = +lisp_sym_nil))
			(v-call :nums :vcreate `(,dst) `(,dst) nums2 iter_begin)
			(call :nums :set_cap `(,dst 4) `(,dst))
			(call :nums :set_length `(,dst 4) `(,dst _))
		(else)
			(assign `((,dst +array_length)) `(,len2))
			(errorif `(,len2 < 4) 'error)
			(call :obj :ref `(,dst) `(,dst))
		(endif)
	(endif)
	(v-call :fixeds :mat4x4_v4_mul `(,dst ,nums1 ,nums2) `(,dst) dst iter_begin)

	(exit :fixeds :lisp_mat4x4_v4_mul `(,this ,dst))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error `(,this "(mat4x4-v4-mul ma v [out])" +error_msg_wrong_types ,args))
	(signature '(:fixeds :fixeds :fixeds)))

(def-func-end)

(def-method :fixeds :lisp_mat3x3_mul)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(vp-rdef (dst iter_begin nums1 nums2 this args argc len1 len2)
		'(:r0 :r6 :r7 :r8 :r9 :r1 :r11 :r12 :r13))

	(entry :fixeds :lisp_mat3x3_mul `(,this ,args))

	(errorif-lisp-args-sig 'error :r1 2 3)

	(assign `((,args +array_length)) `(,argc))
	(assign `((,args +array_begin)) `(,iter_begin))

	(array-get-args iter_begin `(,nums1 ,nums2))

	(assign `((,nums1 +array_length)) `(,len1))
	(errorif `(,len1 /= 9) 'error)
	(assign `((,nums2 +array_length)) `(,len2))
	(errorif `(,len2 /= 9) 'error)

	(vpif `(,argc = 2))
		(v-call :nums :vcreate `(,dst) `(,dst) nums1 iter_begin)
		(call :nums :set_cap `(,dst 9) `(,dst))
		(call :nums :set_length `(,dst 9) `(,dst _))
	(else)
		(vp-cpy-ir iter_begin (* +ptr_size 2) dst)
		(vpif `(,dst = +lisp_sym_nil))
			(v-call :nums :vcreate `(,dst) `(,dst) nums1 iter_begin)
			(call :nums :set_cap `(,dst 9) `(,dst))
			(call :nums :set_length `(,dst 9) `(,dst _))
		(else)
			(assign `((,dst +array_length)) `(,len1))
			(errorif `(,len1 < 9) 'error)
			(call :obj :ref `(,dst) `(,dst))
		(endif)
	(endif)
	(v-call :fixeds :mat3x3_mul `(,dst ,nums1 ,nums2) `(,dst) dst iter_begin)

	(exit :fixeds :lisp_mat3x3_mul `(,this ,dst))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error `(,this "(mat3x3-mul ma mb [out])" +error_msg_wrong_types ,args))
	(signature '(:fixeds :fixeds :fixeds)))

(def-func-end)

(def-method :fixeds :lisp_mat3x3_v3_mul)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(vp-rdef (dst iter_begin nums1 nums2 this args argc len1 len2)
		'(:r0 :r6 :r7 :r8 :r9 :r1 :r11 :r12 :r13))

	(entry :fixeds :lisp_mat3x3_v3_mul `(,this ,args))

	(errorif-lisp-args-sig 'error :r1 2 3)

	(assign `((,args +array_length)) `(,argc))
	(assign `((,args +array_begin)) `(,iter_begin))

	(array-get-args iter_begin `(,nums1 ,nums2))

	(assign `((,nums1 +array_length)) `(,len1))
	(errorif `(,len1 /= 9) 'error)
	(assign `((,nums2 +array_length)) `(,len2))
	(errorif `(,len2 /= 3) 'error)

	(vpif `(,argc = 2))
		(v-call :nums :vcreate `(,dst) `(,dst) nums2 iter_begin) ; using nums2 as template
		(call :nums :set_cap `(,dst 3) `(,dst))
		(call :nums :set_length `(,dst 3) `(,dst _))
	(else)
		(vp-cpy-ir iter_begin (* +ptr_size 2) dst)
		(vpif `(,dst = +lisp_sym_nil))
			(v-call :nums :vcreate `(,dst) `(,dst) nums2 iter_begin)
			(call :nums :set_cap `(,dst 3) `(,dst))
			(call :nums :set_length `(,dst 3) `(,dst _))
		(else)
			(assign `((,dst +array_length)) `(,len2))
			(errorif `(,len2 < 3) 'error)
			(call :obj :ref `(,dst) `(,dst))
		(endif)
	(endif)
	(v-call :fixeds :mat3x3_v3_mul `(,dst ,nums1 ,nums2) `(,dst) dst iter_begin)

	(exit :fixeds :lisp_mat3x3_v3_mul `(,this ,dst))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error `(,this "(mat3x3-v3-mul ma v [out])" +error_msg_wrong_types ,args))
	(signature '(:fixeds :fixeds :fixeds)))

(def-func-end)
