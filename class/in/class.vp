(include "lib/asm/func.inc")
(include "./class.inc")
(include "././sym/class.inc")
(include "././out/class.inc")
(include "././list/class.inc")

(gen-create :in)
(gen-vtable :in)
(gen-type :in)

(def-method :in :init)
	;inputs
	;:r0 = in object (ptr)
	;:r1 = vtable (pptr)
	;:r2 = 0, else mailbox id (uint)
	;outputs
	;:r0 = in object (ptr)
	;:r1 = 0 if error, else ok
	;trashes
	;:r1-:r14

	(vp-rdef (this vtable zero state oid))

	(entry :in :init `(,this ,vtable ,zero))

	;init parent
	(assign `(,zero) `((,this in_mbox_oid)))
	(s-call :in :init `(,this ,vtable 0 0 0 0) `(,this ,vtable))
	(vpif `(,vtable /= 0))
		;init myself
		(assign '(0 stream_mail_state_started) `(,zero ,state))
		(save-fields this '(in_seqnum in_ack_seqnum in_state) `(,zero ,zero ,state))
		(assign `((,this in_mbox_oid)) `(,oid))
		(vp-push this)
		(vpif `(,oid = 0))
			;need a new mailbox
			(call :sys_mail :alloc_mbox :nil `(,oid ,vtable))
		(else)
			;given an existing mailbox
			(call :sys_mail :validate `(,oid) `(,vtable))
		(endif)
		(vp-pop this)
		(save-fields this '(in_mbox_id in_mbox_addr) `(,oid ,vtable))
		(assign `((& ,this in_list)) `(,vtable))
		(lh-init vtable oid)
	(endif)

	(exit :in :init `(,this ,vtable))
	(vp-ret)

(def-func-end)

(def-method :in :deinit)
	;inputs
	;:r0 = in object (ptr)
	;outputs
	;:r0 = in object (ptr)
	;trashes
	;:r1-:r14

	(entry :in :deinit '(:r0))

	;wait till stopped
	(loop-start)
		(assign '((:r0 in_state)) '(:r1))
		(breakif '(:r1 = stream_mail_state_stopped))
		(call :in :next_msg '(:r0) '(:r0))
	(loop-end)

	;free any stream mail buffer
	(vp-push :r0)
	(vp-xor-rr :r1 :r1)
	(assign '((:r0 stream_buffer)) '(:r2))
	(assign '(:r1) '((:r0 stream_buffer)))
	(call :sys_mail :free '(:r2))

	;free any allocated mailbox
	(assign '((:rsp 0)) '(:r0))
	(assign '((:r0 in_mbox_oid) (:r0 in_mbox_id)) '(:r1 :r0))
	(vpif '(:r0 /= :r1))
		(call :sys_mail :free_mbox '(:r0))
	(endif)

	;splice any junk sequence mail to postman
	(assign '((:rsp 0)) '(:r0))
	(call :sys_mail :junk_mail '((& :r0 in_list)))

	;deinit parent
	(vp-pop :r0)
	(s-jump :in :deinit '(:r0))

(def-func-end)

(def-method :in :next_msg)
	;inputs
	;:r0 = in object (ptr)
	;outputs
	;:r0 = in object (ptr)
	;trashes
	;:r1-:r8

	(vp-rdef (msg acknum seqnum bufp bufe state mbox buffer this))
	(vp-rdef (id0 id1 id2 tmp) (list bufp bufe state acknum))

	(entry :in :next_msg `(,this))

	;free any current msg
	(call :sys_mail :free `((,this stream_buffer)))

	;read next in sequence, blocking if not
	(vp-xor-rr msg msg)
	(loop-start)
		(call 'next_seq `(,msg (& ,this in_list) (,this in_seqnum)) `(,buffer))
		(breakif `(,buffer /= 0))
		(call :sys_mail :read `((,this in_mbox_addr)) `(,msg _))
	(loop-end)
	(assign `((,this in_seqnum)) `(,seqnum))
	(vp-add-cr 1 seqnum)
	(assign `(,seqnum) `((,this in_seqnum)))

	;do we have the next msg already ?
	(call 'next_seq `(0 (& ,this in_list) ,seqnum) `(,msg))
	(vpif `(,msg /= 0))
		;put it in the mailbox so 'select' or 'poll' will trigger !
		(assign `((,this in_mbox_addr)) `(,mbox))
		(vp-add-cr mbox_list mbox)
		(lh-add-at-tail mbox msg tmp)
	(endif)

	;save msg buffer details
	(load-fields buffer '(msg_frag_data msg_frag_length) `(,bufp ,bufe))
	(load-fields bufp '(stream_msg_state stream_msg_seqnum) `(,state ,seqnum))
	(vp-add-rr bufp bufe)
	(vp-add-cr stream_msg_data bufp)
	(save-fields this '(stream_buffer stream_bufp stream_bufe in_state)
		`(,buffer ,bufp ,bufe ,state))

	;send ack if needed
	(assign `((,this in_ack_seqnum)) `(,acknum))
	(vp-shr-cr out_ack_shift seqnum)
	(vpif `(,acknum = ,seqnum))
		;next ack seq num
		(vp-add-cr 1 acknum)
		(assign `(,acknum) `((,this in_ack_seqnum)))
		(call :sys_mail :alloc '(0) `(,msg _))
		(assign `((,buffer msg_frag_data)) `(,buffer))
		(load-net-id buffer stream_msg_ack_id id0 id1 id2)
		(save-net-id msg msg_dest id0 id1 id2)
		(call :sys_mail :send `(,msg))
	(endif)

	(exit :in :next_msg `(,this))
	(vp-ret)

(vp-label 'next_seq)
	;inputs
	;:r0 = 0, else new stream msg (ptr)
	;:r1 = list head (ptr)
	;:r2 = seqnum (long)
	;outputs
	;:r0 = 0, else next stream msg (ptr)
	;trashes
	;:r0-:r1, :r3

	(vp-rdef (msg lst seqnum tmp))

	(entry `(,msg ,lst ,seqnum))

	;save any new msg
	(vpif `(,msg /= 0))
		(lh-add-at-tail lst msg tmp)
	(endif)

	;scan for seqnum
	(loop-list-forward lst 0 msg lst)
		(assign `((,msg msg_frag_data)) `(,tmp))
		(assign `((,tmp stream_msg_seqnum)) `(,tmp))
	(loop-until `(,seqnum = ,tmp))
	(vpif `(,lst = 0))
		;not found
		(exit `(,lst))
		(vp-ret)
	(endif)

	;remove found from list
	(vp-cpy-rr msg lst)
	(ln-remove-node lst tmp)

	(exit `(,msg))
	(vp-ret)

(def-func-end)

(def-method :in :read_next)
	;inputs
	;:r0 = in object (ptr)
	;outputs
	;:r0 = in object (ptr)
	;:r1 = -1 for EOF, else more data
	;trashes
	;:r1-:r14

	(entry :in :read_next '(:r0))

	;if started state
	(loop-start)
		(assign '((:r0 in_state)) '(:r1))
		(breakif '(:r1 /= stream_mail_state_started))
		(call :in :next_msg '(:r0) '(:r0))
		(assign '((:r0 stream_bufp) (:r0 stream_bufe)) '(:r1 :r2))
	(loop-until '(:r1 /= :r2))

	;return -1 if not in started state
	(assign '((:r0 in_state)) '(:r2))
	(vp-xor-rr :r1 :r1)
	(vpif '(:r2 /= stream_mail_state_started))
		(vp-cpy-cr -1 :r1)
	(endif)

	(exit :in :read_next '(:r0 :r1))
	(vp-ret)

(def-func-end)
