(include "lib/asm/func.inc")
(include "./class.inc")
(include "././list/class.inc")
(include "././str/class.inc")

(gen-create 'mstream)
(gen-vtable 'mstream)

(def-method 'mstream :init)
	;inputs
	;:r0 = mstream object (ptr)
	;:r1 = vtable (pptr)
	;outputs
	;:r0 = mstream object (ptr)
	;:r1 = 0 if error, else ok
	;trashes
	;:r1-:r14

	(vp-def (this vtable tmp))

	(entry 'mstream :init `(,this ,vtable))

	(s-call 'mstream :init `(,this ,vtable 0 0 0 0) `(,this ,vtable))
	(vpif `(,vtable /= 0))
		(vp-push this)
		(call 'list :create :nil `(,vtable))
		(vp-pop this)
		(vp-xor-rr tmp tmp)
		(save-fields this '(mstream_chunks mstream_pos mstream_total mstream_index)
			`(,vtable ,tmp ,tmp ,tmp))
		(vp-cpy-cr 1 vtable)
	(endif)

	(exit 'mstream :init `(,this ,vtable))
	(vp-ret)

(def-func-end)

(def-method 'mstream :deinit)
	;inputs
	;:r0 = mstream object (ptr)
	;outputs
	;:r0 = mstream object (ptr)
	;trashes
	;:r1-:r14

	(vp-def (this tmp))

	(entry 'mstream :deinit `(,this))

	(vp-push this)
	(call 'obj :deref `((,this mstream_chunks)))
	(vp-pop this)
	(vp-xor-rr tmp tmp)
	(save-fields this '(stream_object stream_buffer) `(,tmp ,tmp))
	(s-jump 'mstream :deinit `(,this))

(def-func-end)

(def-method 'mstream :flush)
	;inputs
	;:r0 = mstream object (ptr)
	;outputs
	;:r0 = mstream object (ptr)
	;trashes
	;:r1-:r9

	(vp-def (this bufp chunk pos total))

	(entry 'mstream :flush `(,this))

	;current position and total size
	(call 'mstream :ptoi `(,this (,this stream_bufp)) `(,this ,bufp ,chunk ,pos ,total))
	(save-fields this '(mstream_pos mstream_total) `(,pos ,total))

	(assign `((,this stream_object)) `(,chunk))
	(vpif `(,chunk /= 0))
		;we have a volatile wright buffer
		(assign `((,this stream_buffer)) `(,total))
		(vp-sub-rr total bufp)
		(assign `(,bufp) `((,chunk str_length)))
		(vp-xor-rr bufp bufp)
		(save-fields this '(stream_object stream_bufp stream_bufe) `(,bufp ,bufp ,bufp))
	(endif)

	(exit 'mstream :flush `(,this))
	(vp-ret)

(def-func-end)

(def-method 'mstream :write_next)
	;inputs
	;:r0 = sstream object (ptr)
	;outputs
	;:r0 = sstream object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(ptr this next_chunk)
		(uint chunk_idx len))

	(push-scope)
	(entry {this})

	(assign {this->mstream_index + 1} {chunk_idx})
	(call 'list :get_length {this->mstream_chunks} {_, len})

	(vpif {chunk_idx < len})
		;moving to an existing chunk
		(call 'list :get_elem {this->mstream_chunks, chunk_idx} {_, next_chunk})
		(assign {&next_chunk->str_data} {this->stream_buffer})
		(assign {this->stream_buffer} {this->stream_bufp})
		(assign {this->stream_buffer + next_chunk->str_length} {this->stream_bufe})
	(else)
		;creating a new volatile chunk
		(call 'str :create_from_buffer {0, mstream_buf_size} {next_chunk})
		(call 'list :push_back {this->mstream_chunks, next_chunk})
		(assign {next_chunk, &next_chunk->str_data} {this->stream_object, this->stream_buffer})
		(assign {this->stream_buffer} {this->stream_bufp})
		(assign {this->stream_buffer + mstream_buf_size} {this->stream_bufe})
	(endif)
	(assign {chunk_idx} {this->mstream_index})
	(exit 'mstream :write_next {this})
	(pop-scope)
	(return)

(def-func-end)

(def-method 'mstream :read_next)
	;inputs
	;:r0 = mstream object (ptr)
	;outputs
	;:r0 = mstream object (ptr)
	;:r1 = -1 for EOF, else more data
	;trashes
	;:r1-:r14

	(def-vars
		(ptr this next_chunk)
		(uint chunk_idx)
		(int len))

	(push-scope)
	(entry {this})
	(assign {this->mstream_index + 1} {chunk_idx})
	(call 'list :get_length {this->mstream_chunks} {_, len})
	(vpif {chunk_idx < len})
		;chunks are available, set pointers for reading
		(call 'list :get_elem {this->mstream_chunks, chunk_idx} {_, next_chunk})
		(assign {&next_chunk->str_data} {this->stream_bufp})
		(assign {this->stream_bufp + next_chunk->str_length} {this->stream_bufe})
		(assign {chunk_idx} {this->mstream_index})
		(assign {0} {len})
	(else)
		;EOF
		(assign {-1} {len})
	(endif)
	(exit 'mstream :read_next {this, len})
	(pop-scope)
	(return)

(def-func-end)

(def-method 'mstream :seek)
	;inputs
	;:r0 = mstream object (ptr)
	;:r1 = offset (long)
	;:r2 = pos (uint)
	;outputs
	;:r0 = mstream object (ptr)
	;:r1 = -1 for error, else file position
	;trashes
	;:r1-:r11

	(vp-def (offset whence this pos bufp bufe chunk buffer index)
		'(:r10 :r11))

	(entry 'mstream :seek `(,this ,offset ,whence))

	;what is the new position
	(call 'mstream :flush `(,this) `(,this))

	(load-fields this '(mstream_total mstream_pos) `(,index ,pos))
	(switch)
	(vpcase `(,whence = 0))
		(vp-cpy-rr offset pos)
		(break)
	(vpcase `(,whence = 1))
		(vp-add-rr offset pos)
		(break)
	(vpcase `(,whence = 2))
		(vp-lea-d index offset pos)
	(endswitch)

	;find the chunk needed
	(call 'mstream :itop `(,this ,pos) `(,this ,pos ,bufp ,bufe ,chunk ,buffer ,index))

	;set the pointers
	(save-fields this
		'(stream_bufp stream_bufe mstream_pos stream_buffer mstream_index)
		`(,bufp ,bufe ,pos ,buffer ,index))

	(exit 'mstream :seek `(,this ,pos))
	(vp-ret)

(def-func-end)

(def-method 'mstream :ptoi)
	;inputs
	;:r0 = mstream object (ptr)
	;:r1 = bufp (pubyte)
	;outputs
	;:r0 = mstream object (ptr)
	;:r1 = bufp (pubyte)
	;:r2 = 0, else chunk str object (ptr)
	;:r3 = 0, else file position (uint)
	;:r4 = 0, else file size (uint)
	;trashes
	;:r1-:r9

	(vp-def (this bufp chunk pos total iter_begin iter_end
		chunk_len chunk_s chunk_e))

	(entry 'mstream :ptoi `(,this ,bufp))

	(assign `((,this mstream_chunks)) `(,iter_begin))
	(assign '(0 0 0) `(,chunk ,pos ,total))
	(class/array/get_both iter_begin iter_begin iter_end)
	(vpif `(,iter_begin /= ,iter_end))
		(loop-start)
			(assign `((,iter_begin 0)) `(,chunk))
			(assign `((,chunk str_length)) `(,chunk_len))
			(assign `((& ,chunk str_data)) `(,chunk_s))
			(assign `((& ,chunk_s ,chunk_len)) `(,chunk_e))
			(vpif `(,bufp >= ,chunk_s) `(,bufp <= ,chunk_e))
				(vp-cpy-rr bufp pos)
				(vp-sub-rr chunk_s pos)
			(endif)
			(vp-add-rr chunk_len total)
			(vp-add-cr +ptr_size iter_begin)
		(loop-until `(,iter_begin = ,iter_end))
	(endif)

	(exit 'mstream :ptoi `(,this ,bufp ,chunk ,pos ,total))
	(vp-ret)

(def-func-end)

(def-method 'mstream :itop)
	;inputs
	;:r0 = mstream object (ptr)
	;:r1 = file position (uint)
	;outputs
	;:r0 = mstream object (ptr)
	;:r1 = file position (uint)
	;:r2 = 0, else bufp (pubyte)
	;:r3 = 0, else bufe (pubyte)
	;:r4 = 0, else chunk str object (ptr)
	;:r5 = 0, else chunk buffer start (pubyte)
	;:r6 = 0, else chunk index (uint)
	;trashes
	;:r1-:r10

	(vp-def (this pos bufp bufe chunk buffer index
		total iter_begin iter_end chunk_len))

	(entry 'mstream :itop `(,this ,bufp))

	(assign `((,this mstream_chunks)) `(,iter_begin))
	(assign '(0 0 0 0 0 0) `(,bufp ,bufe ,chunk ,buffer ,index ,total))
	(class/array/get_both iter_begin iter_begin iter_end)
	(vpif `(,iter_begin /= ,iter_end) 'exit)
		(loop-start)
			(assign `((,iter_begin 0)) `(,chunk))
			(assign `((,chunk str_length)) `(,chunk_len))
			(vp-add-rr chunk_len total)
			(vpif `(,pos < total))
				(assign `((& ,chunk str_data)) `(,buffer))
				(assign `((& ,buffer ,chunk_len)) `(,bufe))
				(vp-cpy-rr bufe bufp)
				(vp-sub-rr pos total)
				(vp-sub-rr total bufp)
				(break 'exit)
			(endif)
			(vp-add-cr 1 index)
			(vp-add-cr +ptr_size iter_begin)
		(loop-until `(,iter_begin = ,iter_end))
		(assign '(0 0) `(,chunk ,index))
	(endif)

	(exit 'mstream :itop `(,this ,pos ,bufp ,bufe ,chunk ,buffer ,index))
	(vp-ret)

(def-func-end)
