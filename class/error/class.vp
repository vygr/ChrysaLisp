(include "lib/asm/func.inc")
(include "sys/str/class.inc")
(include "lib/consts/chars.inc")
(include "./class.inc")
(include "././sym/class.inc")
(include "././sstream/class.inc")
(include "././list/class.inc")

(gen-create :error)
(gen-vtable :error)
(gen-type :error)

(def-method :error :init)
	;inputs
	;:r0 = error object (ptr)
	;:r1 = vtable (pptr)
	;:r2 = description c string (pubyte)
	;:r3 = 0, else error msg index (uint)
	;:r4 = error payload object (ptr)
	;:r5 = script string (ptr)
	;:r6 = stream string (ptr)
	;:r7 = stream line number (uint)
	;:r8 = stack frame (ptr)
	;outputs
	;:r0 = error object (ptr)
	;:r1 = 0 if error, else ok
	;trashes
	;:r1-:r6

	(def-struct local 0
		(ptr this))

	;save inputs
	(vp-alloc local_size)
	(assign '(:r0 :r2 :r3 :r4 :r5 :r6 :r7 :r8)
		'((:rsp local_this) (:r0 +error_description) (:r0 +error_msg i) (:r0 +error_object)
		(:r0 +error_script) (:r0 +error_file) (:r0 +error_line i) (:r0 +error_frame)))

	;init parent
	(s-call :error :init '(:r0 :r1) '(:r0 :r1))
	(vpif '(:r1 /= 0))
		;init self
		(call :str :create_from_cstr '((:r0 +error_description)) '(:r0))
		(assign '((:rsp local_this)) '(:r1))
		(assign '(:r0) '((:r1 +error_description)))
		(call :obj :ref '((:r1 +error_script)))
		(assign '((:rsp local_this)) '(:r0))
		(call :obj :ref '((:r0 +error_file)))
		(assign '((:rsp local_this)) '(:r0))
		(call :obj :ref '((:r0 +error_object)))
		(assign '((:rsp local_this)) '(:r0))
	(endif)

	(vp-free local_size)
	(vp-ret)

(def-func-end)

(def-method :error :deinit)
	;inputs
	;:r0 = error object (ptr)
	;outputs
	;:r0 = error object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(ptr this))

	(push-scope)
	(entry :error :deinit {this})

	(call :obj :deref {this->+error_description})
	(call :obj :deref {this->+error_script})
	(call :obj :deref {this->+error_file})
	(call :obj :deref {this->+error_object})
	(call :obj :deref {this->+error_frame})
	(s-jump :error :deinit {this})

	(pop-scope-syms)

(def-func-end)

(def-method :error :get_msg)
	;inputs
	;:r0 = error object (ptr)
	;outputs
	;:r0 = error object (ptr)
	;:r1 = error c string (pubyte)
	;trashes
	;:r1-:r5

	(entry :error :get_msg '(:r0))

	(assign '(:r0 "" (:r0 +error_msg) ($ msgs)) '(:r3 :r4 :r5 :r0))
	(loop-while '(:r5 /= 0))
		(vp-cpy-ir-ub :r0 0 :r1)
		(breakif '(:r1 = 0))
		(vp-cpy-rr :r0 :r4)
		(call :sys_str :length '(:r0) '(:r0 :r1))
		(vp-add-rr :r1 :r0)
		(vp-sub-cr 1 :r5)
		(vp-add-cr 1 :r0)
	(loop-end)

	(exit :error :get_msg '(:r3 :r4))
	(vp-ret)

(vp-label 'msgs)
(errorcase
	(each (const vp-cstr) *error_msgs*))
(vp-label 'unknown)
	(vp-cstr "unknown_error !")
	(vp-byte 0)

(def-func-end)

(def-method :error :print)
	;inputs
	;:r0 = error object (ptr)
	;:r1 = stream object (ptr)
	;outputs
	;:r0 = error object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(ptr this stream string sstream)
		(uint len))

	(push-scope)
	(entry :error :print {this, stream})

	(call :stream :write_cstr {stream, "Error: "})
	(call :stream :write_cstr {stream, &this->+error_description->+str_data} '(stream))
	(call :stream :write_char `(,stream +char_space))
	(call :error :get_msg {this} {_, string})
	(call :stream :write_cstr {stream, string})

	(call :stream :write_cstr {stream, " Repl: "})
	(call :stream :write_cstr {stream, &this->+error_script->+str_data} '(stream))
	(call :stream :write_char `(,stream +char_space))
	(call :stream :write_cstr {stream, &this->+error_file->+str_data} '(stream))
	(call :stream :write_char `(,stream +char_lrb))
	(call :str :create_from_long {this->+error_line, 10} {string})
	(call :stream :write_cstr {stream, &string->+str_data} '(stream))
	(call :stream :write_char `(,stream +char_rrb))
	(call :str :destroy {string})

	(call :stream :write_cstr {stream, " Frame: "})
	(call :obj :print {this->+error_frame, stream})

	(call :stream :write_cstr {stream, " Obj: "})
	(call :str :create_from_buffer {0, str_gap} {string})
	(call :sstream :create {string} {sstream})
	(call :obj :print {this->+error_object, sstream})
	(call :sstream :ref_string {sstream} {_, string})
	(call :obj :destroy {sstream})
	(assign {string->+str_length} {len})
	(vpif {len > 256})
		(assign {256} {len})
	(endif)
	(call :stream :write {stream, &string->+str_data, len})
	(call :str :destroy {string})

	(exit :error :print {this})
	(pop-scope)
	(return)

(def-func-end)
