(include "lib/asm/func.inc")
(include "././str/class.inc")
(include "././real/class.inc")
(include "././lisp/class.inc")

(def-method :obj :lisp_get)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(vp-rdef (this obj args offset type osize fsize sizes) '(:r8))

	(entry :obj :lisp_get `(,this ,args))

	(errorif-lisp-args-sig 'error :r1 3)

	(list-bind-args args `(,obj ,offset ,type) '(:obj :num :num))

(errorcase
	(gotoif `(,offset < 0) 'error1)
	(gotoif `(,type < +type_real) 'error)
	(vp-cpy-ir obj (- sys_mem_header_heap sys_mem_header_size) osize)
	(assign `((,osize hp_heap_cellsize)) `(,osize))
	(vp-sub-cr sys_mem_header_size osize)
	(vp-cpy-rr type fsize)
	(vpif `(,type = 0))
		(vp-cpy-cr +ptr_size fsize)
	(elseif `(,type < 0))
		(vp-lea-p 'type_sizes sizes)
		(vp-sub-rr type sizes)
		(vp-cpy-ir-ub sizes 0 fsize)
	(endif)
	(vp-add-rr offset fsize)
	(gotoif `(,fsize > ,osize) 'error1))

	(switch)
	(vpcase `(,type >= 0))
		(vpif `(,type = 0))
			;object reference
			(assign `((,obj ,offset)) `(,args))
			(vpif `(,args = 0))
				(assign `((,this lisp_sym_nil)) `(,args))
			(endif)
			(class/obj/ref args obj)
			(exit :obj :lisp_get `(,this ,args))
			(vp-ret)
		(endif)
		;sub struct
		(call :str :create_from_buffer `((& ,obj ,offset) ,type) `(,args))
		(exit :obj :lisp_get `(,this ,args))
		(vp-ret)
	(vpcase `(,type = ,+type_byte))
		(assign `((,obj ,offset b)) `(,obj))
		(break)
	(vpcase `(,type = ,+type_ubyte))
		(assign `((,obj ,offset ub)) `(,obj))
		(break)
	(vpcase `(,type = ,+type_short))
		(assign `((,obj ,offset s)) `(,obj))
		(break)
	(vpcase `(,type = ,+type_ushort))
		(assign `((,obj ,offset us)) `(,obj))
		(break)
	(vpcase `(,type = ,+type_int))
		(assign `((,obj ,offset i)) `(,obj))
		(break)
	(vpcase `(,type = ,+type_uint))
		(assign `((,obj ,offset ui)) `(,obj))
		(break)
	(vpcase `(,type = ,+type_fixed))
		(call :fixed :create `((,obj ,offset)) `(,args))
		(exit :obj :lisp_get `(,this ,args))
		(vp-ret)
	(vpcase `(,type = ,+type_real))
		(call :real :create `((,obj ,offset)) `(,args))
		(exit :obj :lisp_get `(,this ,args))
		(vp-ret)
	(default)
		(assign `((,obj ,offset)) `(,obj))
	(endswitch)
	(call :num :create `(,obj) `(,args))
	(exit :obj :lisp_get `(,this ,args))
	(vp-ret)

(errorcase
(vp-label 'error1)
	(jump :lisp :repl_error `(,this "(obj-get obj offset type)" +error_msg_not_valid_index ,args))
(vp-label 'error)
	(jump :lisp :repl_error `(,this "(obj-get obj offset type)" +error_msg_wrong_types ,args))
(vp-label 'type_sizes)
	(vp-byte 0 8 1 1 2 2 4 4 8 8 8)
	(signature '(:obj :num :num)))

(def-func-end)

(def-method :obj :lisp_set)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(ptr this obj val)
		(int offset))

	(vp-rdef (this args obj offset type val num osize fsize sizes))

	(entry :obj :lisp_set `(,this ,args))

	(errorif-lisp-args-sig 'error :r1 4)

	(push-scope)
	(list-bind-args args `(,obj ,offset ,type ,val) '(:obj :num :num :obj))

(errorcase
	(gotoif `(,offset < 0) 'error1)
	(gotoif `(,type < +type_real) 'error)
	(vp-cpy-ir obj (- sys_mem_header_heap sys_mem_header_size) osize)
	(assign `((,osize hp_heap_cellsize)) `(,osize))
	(vp-sub-cr sys_mem_header_size osize)
	(vp-cpy-rr type fsize)
	(vpif `(,type = 0))
		(vp-cpy-cr +ptr_size fsize)
	(elseif `(,type < 0))
		(vp-lea-p 'type_sizes sizes)
		(vp-sub-rr type sizes)
		(vp-cpy-ir-ub sizes 0 fsize)
	(endif)
	(vp-add-rr offset fsize)
	(gotoif `(,fsize > ,osize) 'error1))

	(assign `(,this ,obj) {this, obj})
	(assign `((,val num_value)) `(,num))
	(switch 'exit)
	(vpcase `(,type >= 0))
		(vpif `(,type = 0))
			;object reference
			(assign `(,val ,offset) {val, offset})
			(call :obj :deref_if `((,obj ,offset)))
			(assign {this, obj, val, offset} `(,this ,obj ,val ,offset))
			(assign `((,this lisp_sym_nil)) `(,this))
			(vpif `(,val = ,this))
				(vp-xor-rr val val)
			(else)
				(class/obj/ref val this)
			(endif)
			(assign `(,val) `((,obj ,offset)))
			(break 'exit)
		(endif)
		;sub struct
		(call :sys_mem :copy `((& ,val str_data) (& ,obj ,offset) ,type))
		(break)
	(vpcase `(,type = ,+type_byte))
		(assign `(,num) `((,obj ,offset b)))
		(break)
	(vpcase `(,type = ,+type_ubyte))
		(assign `(,num) `((,obj ,offset b)))
		(break)
	(vpcase `(,type = ,+type_short))
		(assign `(,num) `((,obj ,offset s)))
		(break)
	(vpcase `(,type = ,+type_ushort))
		(assign `(,num) `((,obj ,offset s)))
		(break)
	(vpcase `(,type = ,+type_int))
		(assign `(,num) `((,obj ,offset i)))
		(break)
	(vpcase `(,type = ,+type_uint))
		(assign `(,num) `((,obj ,offset i)))
		(break)
	(default)
		(assign `(,num) `((,obj ,offset)))
	(endswitch)
	(assign {this, obj} `(,this ,obj))
	(class/obj/ref obj type)
	(pop-scope)

	(exit :obj :lisp_set `(,this ,obj))
	(vp-ret)

(errorcase
(vp-label 'error1)
	(jump :lisp :repl_error `(,this "(obj-set obj offset type)" +error_msg_not_valid_index ,args))
(vp-label 'error)
	(jump :lisp :repl_error `(,this "(obj-set obj offset type val)" +error_msg_wrong_types ,args))
(vp-label 'type_sizes)
	(vp-byte 0 8 1 1 2 2 4 4 8 8 8)
	(signature '(:obj :num :num :obj)))

(def-func-end)

(def-method :obj :lisp_hash)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry :obj :lisp_hash '(:r0 :r1))

	(errorif-lisp-args-len 'error :r1 /= 1)

	(vp-push :r0)
	(defq in (method-input :obj :hash))
	(array-bind-args :r1 in)
	(call :obj :hash in '(_ :r0))
	(call :num :create '(:r0) '(:r1))
	(vp-pop :r0)

	(exit :obj :lisp_hash '(:r0 :r1))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error '(:r0 "(hash obj)" +error_msg_wrong_num_of_args :r1)))

(def-func-end)

(def-method :obj :lisp_type)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry :obj :lisp_type '(:r0 :r1))

	(errorif-lisp-args-len 'error :r1 /= 1)

	(vp-push :r0)
	(defq in (method-input :obj :type))
	(array-bind-args :r1 in)
	(call :obj :type in '(_ :r1))
	(vp-pop :r0)

	(exit :obj :lisp_type '(:r0 :r1))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error '(:r0 "(type-of obj)" +error_msg_wrong_num_of_args :r1)))

(def-func-end)

(def-method :obj :lisp_weak_ref)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry :obj :lisp_weak_ref '(:r0 :r1))

	(errorif-lisp-args-len 'error :r1 /= 1)

	(list-bind-args :r1 '(:r2) '(:obj))
	(assign '((:r0 lisp_sym_nil)) '(:r1))
	(vpif '(:r1 = :r2))
		(class/obj/ref :r1 :r2)
	(else)
		(vp-push :r0)
		(call :num :create '(:r2) '(:r1))
		(vp-pop :r0)
	(endif)

	(exit :obj :lisp_weak_ref '(:r0 :r1))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error '(:r0 "(weak-ref obj)" +error_msg_wrong_num_of_args :r1))
	(signature '(:obj)))

(def-func-end)

(def-method :obj :lisp_obj_ref)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(entry :obj :lisp_obj_ref '(:r0 :r1))

	(errorif-lisp-args-len 'error :r1 /= 1)

	(list-bind-args :r1 '(:r2) '(:obj))
	(assign '((:r0 lisp_sym_nil)) '(:r1))
	(vpif '(:r1 /= :r2))
	(errorcase
		(assign `((@ ,(f-path :num :vtable)) (:r2 obj_vtable)) '(:r3 :r1))
		(gotoif '(:r3 /= :r1) 'error1))
		(assign '((:r2 num_value)) '(:r1))
	(endif)
	(class/obj/ref :r1 :r2)

	(exit :obj :lisp_obj_ref '(:r0 :r1))
	(vp-ret)

(errorcase
(vp-label 'error1)
	(vp-cpy-rr :r2 :r1)
(vp-label 'error)
	(jump :lisp :repl_error '(:r0 "(obj-ref num)" +error_msg_wrong_types :r1))
	(signature '(:obj)))

(def-func-end)

(def-method :obj :lisp_eql)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(vp-rdef (this args obj1 obj2) '(:r9 :r10))

	(entry :obj :lisp_eql `(,this ,args))

(errorcase
	(assign `((,args array_length)) `(,obj1))
	(gotoif `(,obj1 /= 2) 'error))

	(array-bind-args args `(,obj1 ,obj2))
	(call :obj :eql `(,obj1 ,obj2) '(_ tmp))
	(vpif `(,tmp /= 0))
		(assign `((,this lisp_sym_nil)) `(,args))
	(else)
		(assign `((,this lisp_sym_t)) `(,args))
	(endif)
	(class/obj/ref args obj1)

	(exit :obj :lisp_eql `(,this ,args))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error `(,this "(eql obj obj)" +error_msg_wrong_num_of_args ,args)))

(def-func-end)

(def-method :obj :lisp_nql)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(vp-rdef (this args obj1 obj2) '(:r9 :r10))

	(entry :obj :lisp_nql `(,this ,args))

(errorcase
	(assign `((,args array_length)) `(,obj1))
	(gotoif `(,obj1 /= 2) 'error))

	(array-bind-args args `(,obj1 ,obj2))
	(call :obj :eql `(,obj1 ,obj2) '(_ tmp))
	(vpif `(,tmp = 0))
		(assign `((,this lisp_sym_nil)) `(,args))
	(else)
		(assign `((,this lisp_sym_t)) `(,args))
	(endif)
	(class/obj/ref args obj1)

	(exit :obj :lisp_nql `(,this ,args))
	(vp-ret)

(errorcase
(vp-label 'error)
	(jump :lisp :repl_error `(,this "(nql obj obj)" +error_msg_wrong_num_of_args ,args)))

(def-func-end)
