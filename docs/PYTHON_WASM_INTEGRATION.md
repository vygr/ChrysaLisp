# Python and NumPy Integration via WebAssembly

## Current Status

### âœ… What Works Now

ChrysaLisp can successfully load and execute **standalone WebAssembly modules** including:

1. **Simple WASM modules** - Basic functions compiled from C, Rust, etc.
2. **Array processing** - NumPy-style operations compiled to WASM
3. **Memory sharing** - Read/write data between ChrysaLisp and WASM

**Example** (`examples/wasm/array_ops.c`):
```lisp
(defq wasm (Wasm "array_ops.wasm"))
(defq sum (. wasm :call "sum_array" 0 5))        ; Sum array
(defq mean (. wasm :call "mean" 0 5))            ; Calculate mean
(defq dot (. wasm :call "dot_product" 0 100 10)) ; Dot product
```

This demonstrates WASM-based compute similar to what NumPy provides.

### âš ï¸ What Doesn't Work Yet

**Direct Pyodide/Python integration** is not currently possible because:

1. **JavaScript Dependency**: Pyodide requires JavaScript glue code (`pyodide.asm.js`) generated by Emscripten
2. **Runtime Complexity**: Python's WASM builds need complex initialization
3. **WASI Limitations**: Our wasm3 integration has minimal WASI support

## The Pyodide Challenge

### What is Pyodide?

Pyodide is CPython compiled to WebAssembly using Emscripten. It includes:
- Full Python 3.11+ interpreter
- NumPy, Pandas, Matplotlib, and 100+ scientific packages
- ~30MB WASM file + support files

### Why It's Complex

**Pyodide Architecture:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Python Code                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Pyodide API (JavaScript)            â”‚
â”‚  - loadPyodide()                    â”‚
â”‚  - runPython()                      â”‚
â”‚  - pyimport()                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ pyodide.asm.js (Emscripten glue)    â”‚
â”‚  - Memory management                â”‚
â”‚  - Function table setup             â”‚
â”‚  - File system (MEMFS)              â”‚
â”‚  - Exception handling               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ pyodide.asm.wasm                    â”‚
â”‚  - CPython interpreter              â”‚
â”‚  - Python standard library          â”‚
â”‚  - Compiled packages (NumPy, etc)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Essential Files:**
1. `pyodide.mjs` - Loader module
2. `pyodide.asm.js` - ~2MB JavaScript glue code
3. `pyodide.asm.wasm` - ~30MB WebAssembly
4. `python_stdlib.zip` - Python standard library
5. Package files for NumPy, etc.

### Current Blockers

**Problem 1: JavaScript Requirement**

Emscripten generates JavaScript code that handles:
- Memory initialization and growth
- Function table management
- Exception unwinding (uses JavaScript try/catch)
- File system operations (MEMFS)
- Async I/O

**Problem 2: WASI Gap**

Pyodide uses Emscripten's syscall layer, not WASI. Our wasm3 integration would need:
- File system emulation
- Environment variable support
- Clock/time functions
- Random number generation

**Problem 3: Size and Complexity**

- Boot time: ~1-2 seconds
- Memory footprint: 50-100MB minimum
- Requires downloading many files

## Alternative Approaches

### Option 1: py2wasm (Wasmer)

**Status**: Theoretically works, but requires WASI support

```bash
# Create standalone Python WASM
$ py2wasm script.py -o script.wasm

# Run with WASI runtime
$ wasmer run script.wasm
```

**What we'd need**:
- Implement WASI syscalls in `src/host/wasm_wasm3.cpp`
- Add file descriptor table
- Implement WASI imports (fd_write, fd_read, etc.)

**Pros**:
- Creates standalone .wasm files
- No JavaScript required
- Smaller than Pyodide

**Cons**:
- No NumPy (only pure Python)
- Slower than Pyodide
- Requires Python 3.11 toolchain

### Option 2: MicroPython WASM

**Status**: Experimental

MicroPython compiled to WASM is smaller (~300KB) but:
- Still requires JavaScript glue code (Emscripten)
- Limited Python library support
- No NumPy

### Option 3: Compile NumPy Operations to WASM

**Status**: âœ… **This works now!**

Instead of running Python, compile numeric operations directly:

**C/Rust Code:**
```c
long sum_array(long* arr, long count) {
    long sum = 0;
    for (long i = 0; i < count; i++)
        sum += arr[i];
    return sum;
}
```

**ChrysaLisp Usage:**
```lisp
;; Write data to WASM memory
(. wasm :write_memory 0 my_data)

;; Call function (like NumPy)
(defq result (. wasm :call "sum_array" 0 count))
```

**This approach**:
- âœ… Works today with current implementation
- âœ… High performance (compiled code)
- âœ… No dependencies
- âœ… Can replicate most NumPy operations
- âŒ Requires writing C/Rust instead of Python

### Option 4: Full Emscripten Support

**Status**: Future enhancement

Implement Emscripten's JavaScript functionality in ChrysaLisp:

**Required Components:**

1. **Memory Management**:
   ```lisp
   (defun em-malloc (size) ...)
   (defun em-free (ptr) ...)
   (defun em-memory-grow (pages) ...)
   ```

2. **File System (MEMFS)**:
   ```lisp
   (defun em-open (path flags) ...)
   (defun em-read (fd buffer len) ...)
   (defun em-write (fd buffer len) ...)
   ```

3. **Exception Support**:
   ```lisp
   (defun em-invoke (func) ...)  ; try/catch wrapper
   ```

**Effort**: 4-6 weeks for basic Emscripten compatibility

## Path Forward

### Phase 1: Enhanced WASM Integration (Current)

âœ… **Completed**:
- Basic WASM loading and calling
- Memory access
- Simple math functions

ğŸ“‹ **Next Steps**:
- Better memory marshaling (arrays, structs)
- Float/double support
- More test cases

### Phase 2: WASI Support (2-3 weeks)

Add WebAssembly System Interface support:

**File**: `src/host/wasm_wasi.cpp`

```cpp
// WASI syscalls
m3ApiRawFunction(wasi_fd_write) {
    // Implement file descriptor write
}

m3ApiRawFunction(wasi_fd_read) {
    // Implement file descriptor read
}

m3ApiRawFunction(wasi_random_get) {
    // Implement random number generation
}
```

**Benefits**:
- Run py2wasm compiled modules
- Standard POSIX-like interface
- Better ecosystem compatibility

### Phase 3: NumPy-Style Operations (1-2 weeks)

Create a library of compiled array operations:

**File**: `lib/wasm/numpy.inc`

```lisp
(defclass NumPy ()
  (defmethod :sum (array) ...)
  (defmethod :mean (array) ...)
  (defmethod :dot (a b) ...)
  (defmethod :matmul (a b) ...)
)
```

**Implementation**:
- Pre-compiled WASM modules for common operations
- ChrysaLisp wrapper classes
- Automatic data marshaling

### Phase 4: Python Evaluation (Long-term)

Two possible approaches:

**Approach A: Emscripten Layer** (4-6 weeks)
- Implement Emscripten runtime in ChrysaLisp
- Load Pyodide
- Full Python + NumPy support

**Approach B: Compiled Python** (2-3 weeks)
- Use py2wasm for script compilation
- Ahead-of-time compilation only
- Limited library support

## Practical Example: What You Can Do Today

### Simulating Python/NumPy Workflow

**Python Code** (what you want):
```python
import numpy as np

data = [1, 2, 3, 4, 5]
result = np.sum(data) * 2
mean_val = np.mean(data)

print(f"Sum*2: {result}, Mean: {mean_val}")
```

**ChrysaLisp Equivalent** (what works now):
```lisp
(import "class/wasm/lisp.inc")

;; Load pre-compiled array operations
(defq numpy (Wasm "lib/numpy_ops.wasm"))

;; Prepare data in WASM memory
(defq data '(1 2 3 4 5))
(. numpy :write_array 0 data)

;; Call operations
(defq sum_val (. numpy :call "sum" 0 5))
(defq result (* sum_val 2))
(defq mean_val (. numpy :call "mean" 0 5))

(print (cat "Sum*2: " result ", Mean: " mean_val))
```

**Advantages**:
- âœ… Fast (compiled code)
- âœ… No Python interpreter overhead
- âœ… Works today

**Trade-offs**:
- âŒ Must pre-compile operations
- âŒ No dynamic Python code execution
- âŒ Limited to available WASM functions

## Recommendations

### For Immediate Use

**Use Case**: Numeric computations, array processing

**Solution**: Pre-compiled WASM modules

1. Write operations in C/Rust
2. Compile to WASM
3. Call from ChrysaLisp

**Example**: See `examples/wasm/array_ops.c`

### For Future Python Integration

**Short-term** (1-2 months):
1. Add WASI support
2. Test py2wasm integration
3. Create Pythonâ†’WASM workflow

**Long-term** (3-6 months):
1. Implement Emscripten layer
2. Integrate Pyodide
3. Full Python + NumPy support

## Technical Details

### Memory Layout for NumPy-Style Operations

When calling WASM array functions:

```
WASM Linear Memory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” 0x0000
â”‚ Array 1            â”‚ Input data
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ 0x1000
â”‚ Array 2            â”‚ Second input
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ 0x2000
â”‚ Output Array       â”‚ Results
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ 0x3000
â”‚ Scratch Space      â”‚ Temporary data
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Data marshaling**:
```lisp
;; Write ChrysaLisp array to WASM memory
(defun write-array (wasm offset array)
  (each! 0 array
    (# (. wasm :write_memory
          (+ offset (* %0 8))
          (encode-i64 %1)))))

;; Read WASM memory to ChrysaLisp array
(defun read-array (wasm offset count)
  (map (# (decode-i64
           (. wasm :get_memory
              (+ offset (* %0 8)) 8)))
       (range count)))
```

### Performance Comparison

**Hypothetical benchmarks** (array sum of 10,000 elements):

| Method | Time | Notes |
|--------|------|-------|
| Pure Lisp | ~10ms | Interpreted |
| WASM (compiled C) | ~0.1ms | Native speed |
| Python (if available) | ~5ms | Interpreted |
| NumPy (if available) | ~0.2ms | Compiled + overhead |

**Conclusion**: Compiled WASM is fastest option.

## Summary

**What works now**:
- âœ… Load and execute WASM modules
- âœ… Call exported functions
- âœ… Read/write WASM memory
- âœ… Numeric computations (simulating NumPy)

**What's blocked**:
- âŒ Direct Python code execution (needs Emscripten/WASI)
- âŒ Pyodide integration (needs JavaScript layer)
- âŒ Dynamic Python evaluation (needs interpreter)

**Best current approach**:
1. Compile operations to WASM (C/Rust)
2. Create ChrysaLisp wrappers
3. Get NumPy-like functionality without Python

**Future path**:
1. Add WASI support â†’ py2wasm integration
2. Add Emscripten layer â†’ Full Pyodide support
3. Get complete Python + NumPy in ChrysaLisp

The foundation is solid. The next step is choosing between:
- **Quick win**: Build NumPy-style operation library in C/Rust
- **Long-term**: Implement WASI/Emscripten for real Python

Both are achievable with the current WASM integration!
