;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Full App Tree Tracking
; Tracks EVERYTHING - not just UI, but imports, functions, state, comments
; The app IS a tree, so we can serialize the entire tree to Lisp text
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(import "gui_designer/lisp.inc")

;Global app tree (includes ALL forms, not just UI)
(defq *app-tree* (list))
(defq *app-comments* (scatter (Lmap)))  ;line-num -> comment
(defq *app-tracking-enabled* :nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Form Types
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun make-form (type content &optional meta)
	; (make-form type content [meta]) -> form
	; Creates a tracked form (any top-level Lisp expression)
	(scatter (Lmap)
		:form_type type
		:content content
		:meta (ifn meta (scatter (Lmap)))
		:line :nil
		:comment :nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tracking Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun track-import (import-path)
	; (track-import import-path) -> form
	(defq form (make-form :import import-path))
	(when *app-tracking-enabled*
		(push *app-tree* form))
	form)

(defun track-enum (enum-def)
	; (track-enum enum-def) -> form
	(defq form (make-form :enum enum-def))
	(when *app-tracking-enabled*
		(push *app-tree* form))
	form)

(defun track-defq (name value)
	; (track-defq name value) -> form
	(defq form (make-form :defq (scatter (Lmap)
		:name (str name)
		:value (str value))))
	(when *app-tracking-enabled*
		(push *app-tree* form))
	form)

(defun track-defun (name args body)
	; (track-defun name args body) -> form
	(defq form (make-form :defun (scatter (Lmap)
		:name (str name)
		:args (str args)
		:body (str body))))
	(when *app-tracking-enabled*
		(push *app-tree* form))
	form)

(defun track-ui-tree (ui-tree)
	; (track-ui-tree ui-tree) -> form
	(defq form (make-form :ui ui-tree))
	(when *app-tracking-enabled*
		(push *app-tree* form))
	form)

(defun track-expression (expr)
	; (track-expression expr) -> form
	; Generic expression (like event connections, etc.)
	(defq form (make-form :expression (str expr)))
	(when *app-tracking-enabled*
		(push *app-tree* form))
	form)

(defun track-comment (text line-num)
	; (track-comment text line-num) -> :nil
	(when *app-tracking-enabled*
		(. *app-comments* :insert line-num text))
	:nil)

(defun app-tracking-reset ()
	; (app-tracking-reset) -> :nil
	(setq *app-tree* (list))
	(setq *app-comments* (scatter (Lmap)))
	:nil)

(defun app-tracking-enable ()
	; (app-tracking-enable) -> :nil
	(setq *app-tracking-enabled* :t)
	:nil)

(defun app-tracking-disable ()
	; (app-tracking-disable) -> :nil
	(setq *app-tracking-enabled* :nil)
	:nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tree Visitation and Serialization
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun serialize-form (form indent)
	; (serialize-form form indent) -> str
	; Serializes a single form to Lisp text
	(defq type (get :form_type form)
		content (get :content form)
		result "")

	;Add leading comment if present
	(when (get :comment form)
		(setq result (cat result ";" (get :comment form) (ascii-char 10))))

	;Serialize based on type
	(case type
		(:import
			(setq result (cat result "(import \"" content "\")")))

		(:enum
			(setq result (cat result (str content))))

		(:defq
			(setq result (cat result
				"(defq " (get :name content) " " (get :value content) ")")))

		(:defun
			(setq result (cat result
				"(defun " (get :name content) " " (get :args content)
				(ascii-char 10)
				(get :body content)
				")")))

		(:ui
			;Serialize the UI tree
			(import "gui_designer/serialize.inc")
			(setq result (cat result (designer-serialize-tree content))))

		(:expression
			(setq result (cat result content)))

		(:t
			(setq result (cat result ";Unknown form type: " (str type)))))

	result)

(defun serialize-app-tree (app-tree)
	; (serialize-app-tree app-tree) -> str
	; Visits every form in the app tree and serializes to complete Lisp source
	(defq result "")

	;Add header comment
	(setq result (cat result
		";Auto-generated by ChrysaLisp Designer" (ascii-char 10)
		";Full app tree serialization" (ascii-char 10)
		(ascii-char 10)))

	;Visit each form in order
	(each (lambda (form)
		(setq result (cat result
			(serialize-form form 0)
			(ascii-char 10)
			(ascii-char 10))))
		app-tree)

	result)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Enhanced Loading with Full Tracking
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun parse-app-to-tree (source-code)
	; (parse-app-to-tree source-code) -> app-tree
	; Parses source and builds a complete app tree
	; This is a simplified parser - full implementation would use proper Lisp reader

	(app-tracking-reset)
	(app-tracking-enable)

	(defq lines (split source-code (ascii-char 10))
		line-num 0
		current-form :nil)

	(each (lambda (line)
		(defq trimmed (trim line))

		(cond
			;Comment
			((starts-with ";" trimmed)
				(track-comment trimmed line-num))

			;Import
			((find "(import" trimmed)
				(track-import trimmed))

			;Enum
			((or (find "(enums" trimmed) (find "(enum " trimmed))
				(track-enum trimmed))

			;Defq
			((find "(defq" trimmed)
				(track-defq trimmed trimmed))

			;Defun
			((find "(defun" trimmed)
				(track-defun trimmed trimmed trimmed))

			;UI form
			((or (find "(ui-window" trimmed) (find "(ui-root" trimmed))
				;Would track the UI tree here
				(track-expression trimmed))

			;Other expression
			((and (nempty? trimmed) (starts-with "(" trimmed))
				(track-expression trimmed)))

		(++ line-num))
		lines)

	*app-tree*)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Complete Serialization Example
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun demo-full-tree-serialization ()
	; (demo-full-tree-serialization) -> :nil
	(print "")
	(print "╔════════════════════════════════════════════════════╗")
	(print "║  Full App Tree Serialization Demo                 ║")
	(print "╚════════════════════════════════════════════════════╝")
	(print "")

	;Manually build a complete app tree
	(app-tracking-reset)
	(app-tracking-enable)

	;Track imports
	(track-import "././login/env.inc")
	(track-import "gui/lisp.inc")

	;Track state
	(track-defq "*counter*" "0")

	;Track function
	(track-defun "increment" "()" "(++ *counter*)")

	;Track UI (would be actual UI tree)
	(track-expression "(ui-window *window* ())")

	;Track main
	(track-defun "main" "()" "(print \"Started\")")

	;Serialize entire tree
	(defq serialized (serialize-app-tree *app-tree*))

	(print "Complete serialized app:")
	(print "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	(print serialized)
	(print "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	(print "")

	(print "Forms captured: " (str (length *app-tree*)))
	(print "")
	(print "Every aspect of the app is now in tree form and")
	(print "can be:")
	(print "  • Visited")
	(print "  • Modified")
	(print "  • Serialized")
	(print "  • Saved")
	(print "")
	(print "No diff/merge needed - the tree IS the complete app!")
	(print ""))
